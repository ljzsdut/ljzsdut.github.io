<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on ljzsdut</title><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/</link><description>Recent content in Python on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/01-%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/01-%E6%A6%82%E8%BF%B0/</guid><description>一、python程序结构 1.1、程序结构 Python程序可以分解成模块、语句、表达式、对象，如下所示：
程序由模块构成。 模块包含语句。 语句包含表达式。 表达式建立并处理对象。 1.2、python语句的书写规则 python不像其他语言那样，使用各种括号来组织代码，而是使用了缩进来实现代码的结构。
复合语句的首行以冒号结尾，例如for语句，if语句
判断语句条件的括号是可选的
语句的终止是回车（终止行），分号是可选的
缩进的结束就是代码块的结束
python中一般是每条语句占一行。如果想要让多条简单语句（不是复合语句）在同一行中，使用分号分隔。例如：a=2;b=4；如果想让一条语句占用多行，那就使用括号（各种括号）将他们包含起来。
二、python3的虚拟环境 Python 虚拟环境 pyenv、venv(pyvenv)、virtualenv之间的区别
Python3.3+的版本通过venv模块原生支持虚拟环境，可以代替Python之前的virtualenv。
该venv模块提供了创建轻量级“虚拟环境”，提供与系统Python的隔离支持。每一个虚拟环境都有其自己的Python二进制（允许有不同的Python版本创作环境），并且可以拥有自己独立的一套Python包。他最大的好处是，可以让每一个python项目单独使用一个环境，而不会影响python系统环境，也不会影响其他项目的环境。
2.1、优点 使不同应用开发环境独立 环境升级不影响其他应用，也不会影响全局的python环境 防止系统中出现包管理混乱和版本冲突 2.2、创建虚拟环境 创建 py3 虚拟环境(-m表示将模块作为脚本运行) # python3.6 -m venv -h 查看模块venv的帮助 $ python3.6 -m venv /opt/py3 载入 py3 虚拟环境 # 每次操作都需要使用下面的命令载入 py3 虚拟环境 $ source /opt/py3/bin/activate # 偷懒可以在 ~/.bashrc 末尾加入 source /opt/py3/bin/activate # 关闭虚拟环境 $ deactivate 三、真与假 Python中，真和假是每个对象的固有属性，每个对象要么为真要么为假：
数字零为假；
空对象为假；
None对象为假
即False包含：零、空对象、None对象
bool类型只是扩展了真与假的概念，bool值为True（1）和False（0），注意首字母大写，他们只不过是整数1和整数0的定制版本而已。 例如：
prinf(True==2) #False prinf(True==1) #True 四、输入与输出 4.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/02-%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/02-%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D/</guid><description>在Python中，一切皆为对象。
对象与类的关系 ​ 对象就是其类型的实例，创建对象就是对该类（class）进行实例化（instance）。实例被创建后，其身份id和类型type就不可再被改变，值根据是否为可变对象而定。
如何创建对象 ​ 对象创建使用对象定义表达式(如列表[])或工厂函数（如set()）创建。这些表达式和工厂函数决定了创建和使用的对象的类型。
# 对象定义表达式 li=[1,2,3] s=set(&amp;gt;&amp;gt;&amp;gt; li=[1,2,3] &amp;gt;&amp;gt;&amp;gt; li [1, 2, 3] # 工厂函数 &amp;gt;&amp;gt;&amp;gt; s=set(li) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3}) ​ 一旦创建了一个对象，对象的类型就确定了，那么它就和特定操作集合绑定了，例如对字符串只可以进行字符串相关的操作，对列表只可以进行列表相关的操作。
可变对象与不可变对象 ​ 在Python中，每一个对象都可以分为不可变对象或可变对象。
不可变对象：对象的值是不可修改的。主要有：数值型、字符串、元组。对象这种不可变性可以用来保证在程序中保持一个对象固定不变。
可变对象：对象的值是可以修改的，可以在内存原处修改，此处注意“可变”指的是对象的值而不是变量的值。主要有：列表和字典
这里要理解指向不可变对象的变量重新赋值的操作：例如str1=’aa’，我们重新赋值str1=’bb’，因为字符串是不可变对象
判断某个对象是否为某个类实例化而来：isinstance(obj,class)，如果obj为class实例化而来，返回Ture，否则返回False。例如：isinstance(“hello”，str)返回True。
对象的特征 Python程序中存储的所有数据都是对象，每个对象都有一个身份，一个类型，一个值。
身份：id()获取，身份是指向对象在内存中所处位置的指针（其在内存中的地址），注意变量名就是引用这个具体位置的名称（变量名引用对象的过程）
类型：type()获取，也称之为“类别”。对象的类型决定了它所能够支持的方法和能够参与的操作。这个特性说明了Python是一种强类型语言（bash是弱类型语言，默认所有的变量类型为字符串）；
值
&amp;gt;&amp;gt;&amp;gt; s=&amp;#34;hello&amp;#34; &amp;gt;&amp;gt;&amp;gt; id(s) 4305113776 &amp;gt;&amp;gt;&amp;gt; type(s) &amp;lt;class &amp;#39;str&amp;#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; s &amp;#39;hello&amp;#39; &amp;gt;&amp;gt;&amp;gt; 两个对象的比较 值比较：num1 == num2
身份比较：num1 is num2，两个变量名是否引用的时同一个对象(内存地址是否相等)。
类型比较：type(num1) is tpye(num2)，比较两个对象的类型是否相同。
对象的属性与方法 大多数对象都拥有大量的&amp;quot;数据属性&amp;quot;和&amp;quot;方法&amp;quot;
属性：与对象相关的值。对象是由类实例化而来，在实例化时（创建对象时），会给对象内部变量进行赋值，这些内部的可用变量就是对象的属性。
方法：指被调用时将在对象上执行某些操作的函数。方法就是与特定的对象相关联在一起的函数。
属性和方法的访问需要使用点运算符，函数被调用时使用括号运算符。
​ 调用属性，返回属性数据，显示一般需要使用print()</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/03-%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/03-%E5%8F%98%E9%87%8F/</guid><description>类型属于对象，而不是变量 ​ 在Python中，变量并不需要预声明，变量会在第一次赋值时创建，任何类型的对象都可以赋值给一个变量，但是变量一旦被赋值，其对应的类型就已经确定了。
​ 需要注意的是：虽然变量不需要提前声明，但是在使用变量之前必须对其赋值以完成变量的创建。实际上，在对变量使用之前，一般将变量赋值成空对象。（变量是没有类型的，对象才有类型。变量的类型指的是变量指向的对象的类型。）
​ Python中，变量是动态类型的，变量不需要预声明，变量的类型是动态的，它自动地跟踪指向对象的类型。所以，在任何时刻，在需要时，某个变量都可以重新引用一个不同的对象，并且可以是不同的数据类型的对象。
​ 但是Python也是强类型语言（对象存在不同是数据类型，你只能对一个对象进行适合该类型的有效的操作，而bash是弱类型语言，所有的对象都是字符串类型）。
​ 变量名没有类型，类型属于对象，而不是变量，例如我们可以对同一个变量先后赋值不同类型的对象。这跟C语言中不同（c中变量是有类型的，只能赋值相关类型的对象给变量）
变量命名原则 只能包含字母、数字和下划线，且不能数字开头； 区分大小写； 禁止使用保留字（关键字）（python2与python3保留字不同） 变量命名惯例 以单一下划线开头的变量名（_x）不会被from module import语句导入。 前后都有双下划线的变量名（__x__）是系统定义的变量名，对python解释器有特殊意义。 前双下划线的变量名（__x）是类的本地变量，在类的内部使用；类外部无法调用_ 交互模式下，变量名为&amp;quot;_&amp;quot;的变量，用于保持最后表达式的结果。 注意：变量名没有类型，对象才有，变量引用的对象才有，在Python中变量可以引用任意类型的对象。变量名只是内存引用的标识而已。
变量赋值与对象引用 对象引用 ​ Python中一切皆对象。python将所有数据都存储为内存对象（有内存地址），各种内存对象在不被引用时（引用计数为0时），会自动地由垃圾收集器回收。
​ python中，变量本质是一个指针指向了对象的内存空间（引用=指针=内存地址）。
​ ​ 上图表示a=3的赋值过程，做如下说明：
变量和对象保存在内存中的不同部分，并通过连接来关联它们（这个连接在图显示为一个箭头）。在Python中从变量到对象的连接称作引用。也就是说，引用是一种关系，以内存中的指针的形式实现。 对象是分配的一块内存，要有足够的空间去表示它们所代表的值。 引用是自动形成的从变量到对象的指针。
“=”是赋值操作，用于将变量名与内存中的某对象进行绑定（连接）；如果对象事先存在，就直接绑定；否则，则由“=”创建引用对象。
变量总是连接到对象，并且绝不会连接到其他变量上，但是对象可能连接到其他的对象（例如，一个列表对象能够连接到它所包含的对象）。
从概念上讲，在脚本中，每一次通过运行一个表达式生成一个新的值，Python都创建了一个新的对象（换言之，一块内存）去表示这个值。
但是Python从内部做了一种优化，Python缓存了不变的对象并对其进行复用，例如，小的整数和字符串（每一个0都不是一块真正的、新的内存块）。但是，从逻辑的角度看，这工作起来就像每一个表达式结果的值都是一个不同的对象，而每一个对象都是不同的内存。
从技术上来讲，对象有更复杂的结构而不仅仅是有足够的空间表示它的值那么简单。每一个对象都有两个标准的头部信息：一个类型标志符去标识这个对象的类型，以及一个引用计数器，用来决定是不是可以回收这个对象。
共享引用 Python中，赋值操作总是储存对象的引用，而不是这些对象的拷贝。例如多个变量名引用了同一个对象。
&amp;gt;&amp;gt;&amp;gt; a=3 &amp;gt;&amp;gt;&amp;gt; b=a &amp;gt;&amp;gt;&amp;gt; id(a) 15105080 &amp;gt;&amp;gt;&amp;gt; id(b) 15105080 1. 共享引用之不可变对象：对于不可变对象，通过其中一个变量名对对象的修改不会影响其他变量的值。
2. 共享引用之可变对象（原处修改）：对于可变对象，通过其中一个变量名对对象的修改会将对象在原处修改，从此影响其他变量的值，即所有变量的值都发生改变。对于可变变量，可以使用序列的列表机制或模块的深复制来解决这个问题，如b=a[:]赋值，会产生a列表的以个副本来赋值给变量b（分片会产生新的对象）。
说明列表的原处修改修改的是元素的引用。
在原处修改可变对象时可能会影响程序中其他地方对相同对象的其他引用，如果要避免出现这种情况，需要明确地告诉Python复制该对象，复制对象的方法有如下：
没有限制条件的分片表达式（L[:]）能够复制序列。
字典copy方法（X.copy()）能够复制字典。
有些内置函数（例如，list）能够生成拷贝（list(L)）。
copy标准库模块能够生成完整拷贝。copy.deepcopy(list1)、copy.copy(list1)
拷贝需要注意的是：无条件值的分片以及字典copy方法只能做顶层复制。也就是说，不能够复制嵌套的数据结构（如果有的话）。如果你需要一个深层嵌套的数据结构的完整的、完全独立的拷贝，那么就要使用标准的copy模块，copy.deepcopy(list1)
对象的深拷贝和浅拷贝 使用copy模块实现对象的深浅拷贝。
1、 对于&amp;quot;数字&amp;quot;和&amp;quot;字符串&amp;quot;而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。
2、 列表、字典、集合</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/03.1-%E5%90%84%E7%A7%8D%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/03.1-%E5%90%84%E7%A7%8D%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5/</guid><description>赋值语句的特性 赋值语句建立对象引用值。 ​ Python赋值语句会把对象引用值存储在变量名或数据结构的元素内。赋值语句总是建立对象的引用值，而不是复制对象。因此，Python变量更像是指针，而不是数据存储区域。
变量名在首次赋值时会被创建。 ​ Python会在首次将值（即对象引用值）赋值给变量时创建其变量名。有些（并非全部）数据结构元素也会在赋值时创建（例如，字典中的元素，一些对象属性）。一旦赋值了，每当这个变量名出现在表达式时，就会被其所引用的值取代。
变量名在引用前必须先赋值。 ​ 使用尚未进行赋值的变量名是一种错误。如果你试图这么做，Python会引发异常，而不是返回某种模糊的默认值；如果返回默认值，就很难在程序中找出输入错误的地方。
执行隐式赋值的一些操作。 ​ 除=语句之外，在Python中，赋值语句会在许多情况下被隐式使用。例如，模块导入、函数和类的定义、for循环变量以及函数参数全都是隐式赋值运算。因为赋值语句在任何出现的地方的工作原理都相同，所有这些环境都是在运行时把变量名和对象的引用值绑定起来而已。
各种赋值语句 1. 基本形式 spam = 'Spam' 2. 序列解包 序列（包括字符串、元组及列表）分解赋值
spam, ham = &amp;#39;yum&amp;#39;, &amp;#39;YUM&amp;#39; [spam, ham] = [&amp;#39;yum&amp;#39;, &amp;#39;YUM&amp;#39;] a, b, c, d = &amp;#39;spam&amp;#39; 当在“=”左边编写元组或列表时，Python会按照位置把右边的对象和左边的目标根据位置从左至右相配对。例如第一个中，字符串&amp;rsquo;yum&amp;rsquo;赋值给变量名spam，而变量名ham则绑定至字符串&amp;rsquo;YUM&amp;rsquo;。
从内部实现上来看，Python会先在右边制作元素的元组，所以这通常被称为元组分解赋值语句。分解赋值语句必须满足右边的元素个数等于左边的变量个数，其次右边可以为任何的可迭代对象。
分解赋值语句也是一种交换两变量的值，却不需要自行创建临时变量的方式：右侧的元组会自动记住先前的变量的值。例如a,b=b,a
分解赋值语句可以使用嵌套：((a, b), c) = ('SP', 'AM')
3. 扩展的序列解包： 变量列表中某一个变量使用*前缀+变量名的方式表示，这种情况下，可以实现等号两边元素个数不一致的情况。此时，会将等号右表所有剩余的元素以列表的形式赋值给带星号的变量。
&amp;gt;&amp;gt;&amp;gt; a,b,*c=1,2,3,4,5,6 &amp;gt;&amp;gt;&amp;gt; a,b,c (1, 2, [3, 4, 5, 6]) &amp;gt;&amp;gt;&amp;gt; a,*b,c=1,2,3,4,5,6 &amp;gt;&amp;gt;&amp;gt; a,b,c (1, [2, 3, 4, 5], 6) &amp;gt;&amp;gt;&amp;gt; *a,b,c=1,2,3,4,5,6 &amp;gt;&amp;gt;&amp;gt; a,b,c ([1, 2, 3, 4], 5, 6) 注意：扩展的序列解包时，等号左边不能同时出现≥2个带星号的变量，并且带星号的变量不能单独出现，必须以序列元素的形式出现。如(*a,)、[*a]、*a</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/04-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/04-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/</guid><description>python内置数据类型：（又称“核心类型”） 数字类型：int、long、float、complex、bool
字符型：str、unicode
列表：list
字典：dict
元组：tuple
文件：file
其他类型：集合（set），冻结集合/不可变集合frozenset，type类型，None
分类 在Python中有三个主要类型（以及操作）的分类： 1、 数字（整数、浮点数、二进制、分数等）
​ 支持加法和乘法等。
2、 序列（字符串、列表、元组）
​ 支持索引、分片和合并等。
3、 映射（字典）
​ 支持通过键的索引等。
4、 其他：（set、file、type、None）
根据是否可以在内存原处修改，Python中的主要核心类型划分为如下两类 不可变类型（数字、字符串、元组、不可变集合） ​ 不可变的分类中没有哪个对象类型支持原处修改，尽管我们总是可以运行表达式来创建新的对象并将其结果分配给变量。 不可变类型有某种完整性，保证这个对象不会被程序的其他部分改变。
可变类型（列表、字典、可变集合） ​ 相反，可变的类型总是可以通过操作原处修改，而不用创建新的对象。尽管这样的对象可以复制，但原处修改支持直接修改。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/05-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/05-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</guid><description>基础数字类型 基础数字类型：int（long）、float
bool类型: True:1 False:0
Python除了int和float外，还包括了一些较为少见的数字对象，例如复数、固定精度十进制数、有理数、集合和布尔值，第三方开源扩展领域甚至包含了更多（矩阵和向量）。
Python中的数字支持一般的数学运算。例如，加号（+）代表加法，星号（*）表示乘法，双星号（**）表示乘方。
整数的不同进制表示 十六进制数以0x或0X开头，后面接十六进制的数字0～9和A～F。十六进制的数字编写成大写或小写都可以。
八进制数常量以数字0o或0O开头（0和小写或大写的字母&amp;quot;o&amp;quot;），后面接着数字0～7构成的字符串。在Python 2.6及更早的版本中，八进制常量也可以写成前面只有一个0的形式，但在Python 3.0中不能这样（这种最初的八进制形式太容易与十进制数混淆，因此用新的0o的形式替代了）。
二进制常量，以0b或0B开头，后面跟着二进制数字（0～1）。
注意十六进制、八进制、二进制常量在程序代码中都产生一个整数对象，它们仅仅是某个特定整数值的不同语法表示而已。内置函数hex(I)、oct(I)和bin(I)把一个整数转换为这3种进制表示的字符串，并且int(str,base)根据每个给定的进制把一个字符串转换为一个整数。
&amp;gt;&amp;gt;&amp;gt; 0xff,0b11111111,0o377 (255, 255, 255) &amp;gt;&amp;gt;&amp;gt; id(0xff) 23352136 &amp;gt;&amp;gt;&amp;gt; id(0b11111111) 23352136 &amp;gt;&amp;gt;&amp;gt; id(0o377) 23352136 数字类型的表达式操作符 +、-、*、/、＞＞、**、＆等。
附：下图为python中所有的操作符表达式（优先级由低到高排序，同一行从左到右）：
操作符 描述
连续比较 Python允许我们把大小比较测试连接起来，成为诸如范围测试的连续比较。例如，表达式(A＜B＜C)测试B是否在A和C之间；它等同于布尔测试(A＜B and B＜C)，但更容易辨识（和录入）。
真除法与floor除法 真除法：10/4 结果为float
floor除法：10//4 结果为int
区别说明：
python3中x/y表示真除法，无论任何数据类型都会保留小数部分。 python3中，//的结果的数据类型依赖于操作数的类型，如果操作数中有一个是浮点数，结果就是浮点数，否则返回整数。此外还有一点，小数位如果有，则为0，直接效果是向下舍入。
&amp;gt;&amp;gt;&amp;gt; 10/4 2.5 &amp;gt;&amp;gt;&amp;gt; 10//4 2 &amp;gt;&amp;gt;&amp;gt; 10/4.0 2.5 &amp;gt;&amp;gt;&amp;gt; 10//4.0 2.0 数字类型间的自动类型转换 ​ 在混合类型的表达式中，Python首先将被操作的对象转换成其中最复杂的操作对象的类型，然后再对相同类型的操作对象进行数学运算。如果你使用过C语言，你会发现这个行为与C语言中的类型转换是很相似的。 Python是这样划分数字类型的复杂度的：整数比浮点数简单，浮点数比复数简单。所以，当一个整数与浮点数混合时，整数首先会升级转为浮点数的值，之后通过浮点数的运算法则得到浮点数的结果。类似地，任何混合类型的表达式，其中一个操作对象是更为复杂的数字，则会导致其他的操作对象升级为一个复杂的数字，使得表达式获得一个复杂的结果。
​ 再者，要记住所有这些混合类型转换仅仅发生在数字类型混合表达式中（例如，一个整数和一个浮点数），这包括那些使用数字和比较操作符的表达式。一般来说，Python不会在其他的类型之间进行转换。例如，一个字符串和一个整数相加，会产生错误，除非你手动转换其中某个的类型。
内置函数 pow(x,y)幂运算、abs()绝对值、max()、 min()、sum(sequence[, start]) 、round()、int、hex、bin等
sum ((2,3,4),1) sum([2,3,4]) hex(number) --&amp;gt; string oct(number) -&amp;gt; string bin(number) -&amp;gt; string int(x[, base]) -&amp;gt; integer 将数字字符串转换为整数：base指定x的进制，int()将base进制的x字符串转换为10进制的整数 &amp;gt;&amp;gt;&amp;gt; hex(5) &amp;#39;0x5&amp;#39; &amp;gt;&amp;gt;&amp;gt; int(&amp;#39;0x5&amp;#39;,16) 5 数学模块 math.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/06-%E5%BA%8F%E5%88%97%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/06-%E5%BA%8F%E5%88%97%E6%A6%82%E8%BF%B0/</guid><description>python中的序列有字符串、列表、元组。
序列的特点是：有序（元素从左到右排序）、索引、分片（序列中的元素根据他们的相对位置进行存储和读取）
索引 ​ 在Python中，索引是按照从最前面的偏移量进行编码的，也就是从0开始，第一项索引为0，第二项索引为1，依此类推。
​ 在Python中，还反向索引，从最后一个开始索引，最后一个元素的索引号为-1，倒数第二个索引为-2（正向索引是从左边开始计算，反向索引是从右边开始计算）。正反向索引的关系：元素个数=正向索引+反向索引的绝对值，例如str[-1]=str[len(str)-1]。
​ 序列通过str[index]的方式来指定元素。值得注意的是，我们能够在方括号中使用任意表达式，而不仅仅是使用数字常量——可以使用一个常量、一个变量或任意表达式。Python的语法在这方面是完全通用的。
切片 除了简单地从位置进行索引，序列也支持一种所谓分片（slice）的操作，这是一种能够一次提取整个序列中某个片段的方法。分片操作的结果返回一个新的对象。例如：seq[i:j]，i表示分片的起始元素的索引号，缺省时为0；j表示结束索引号，缺省时为len(seq)。需要注意的是，分片操作所取的元素不包含j元素。通俗地将就是seq[i:j]截取索引号为i≤index＜j的元素，即前闭后开区间。例如：
&amp;gt;&amp;gt;&amp;gt; str1=&amp;#39;spam&amp;#39; &amp;gt;&amp;gt;&amp;gt; print str1 spam &amp;gt;&amp;gt;&amp;gt; print str1[1:3] pa &amp;gt;&amp;gt;&amp;gt; print str1[1:-1] pa &amp;gt;&amp;gt;&amp;gt; print str1[1:] pam &amp;gt;&amp;gt;&amp;gt; print str1[1:len(str1)] pam &amp;gt;&amp;gt;&amp;gt; print str1[:-1] spa &amp;gt;&amp;gt;&amp;gt; print str1[:] spam 序列的+运算 加号（+）对于不同的对象有不同的意义：对于数字为加法，对于字符串为合并，对于序列为拼接。
这是Python的一般特性，即“多态”。简而言之，一个操作的意义取决于被操作的对象。正如将在学习动态类型时看到的那样，这种多态的特性给Python代码带来了很大的简洁性和灵活性。由于类型并不受约束，Python编写的操作通常可以自动地适用于不同类型的对象，只要它们支持一种兼容的接口（就像这里的+操作一样）。这成为Python中很重要的概念。此外，str1*3 等同于str1+str1+str1
&amp;gt;&amp;gt;&amp;gt; s1=[1,2,3] &amp;gt;&amp;gt;&amp;gt; s2=[4,5] &amp;gt;&amp;gt;&amp;gt; s3=s1+s2 &amp;gt;&amp;gt;&amp;gt; print s3 [1, 2, 3, 4, 5] &amp;gt;&amp;gt;&amp;gt; num1=1 &amp;gt;&amp;gt;&amp;gt; num2=2 &amp;gt;&amp;gt;&amp;gt; num3=num1+num2 &amp;gt;&amp;gt;&amp;gt; print num3 3 其他序列操作 len() : min():字符按照assic比较大小 max() sum()：只适用于数字序列 all(iterable):检查序列中所有项是否为True any(iterable):任意一项为True则返回True 【说明】：以上为序列的通用操作，所有的序列类型（包括字符串、列表、元组）都可以进行以上操作。除此之外，每种特定的序列对象还有自己特定的操作，我们称之为“方法”。注意区分序列的“操作”与“方法”，序列操作是通用的，但方法不通用：可作用于多种类型的通用型操作都是以内置函数或表达式的形式出现的，例如，len(X)，X[0]，但是类型特定的操作是以方法调用的形式出现的，例如，aString.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/07-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/07-%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>字符串定义 定义 字符串是一系列单个字符的有序序列（一个有序的字符的集合）。主要类型有：str、unicode。
Python字符串需要包括在单引号或双引号中（Python中，单引号或双引号代表着相同的东西），也可以包括在在三个引号（单引号或双引号）中。在三引号中，可以包括多行字符串常量。当采用这种形式的时候，所有的行都合并在一起，并在每一行的末尾增加换行符。
&amp;gt;&amp;gt;&amp;gt; msg=&amp;#34;&amp;#34;&amp;#34;aaa ... bbb&amp;#39;&amp;#39;ccc&amp;#39;ddd&amp;#34;&amp;#34;eee&amp;#34;fff ... ggg&amp;#34;&amp;#34;&amp;#34; &amp;gt;&amp;gt;&amp;gt; print msg aaa bbb&amp;#39;&amp;#39;ccc&amp;#39;ddd&amp;#34;&amp;#34;eee&amp;#34;fff ggg &amp;gt;&amp;gt;&amp;gt; msg &amp;#39;aaa\nbbb\&amp;#39;\&amp;#39;ccc\&amp;#39;ddd&amp;#34;&amp;#34;eee&amp;#34;fff\nggg&amp;#39; 转义字符 Python还提供了各种编写字符串的方法，例如，用反斜线转义序列代表特殊字符。
常见的转移字符如下：
转义字符 描述 \ 忽视newline（续行） \ 反斜杠“\” \’ 单引号 \” 双引号 \a 响铃（alarm） \b 回退（backspace） \f 换页 \n 换行 \r 回车 \t 横向制表符(Tab) \v 纵向制表符 \x 十六进制值 说明：如果Python没有作为一个合法的转义编码识别出在“\”后的字符，它就直接在最终的字符串中保留反斜杠。
&amp;gt;&amp;gt;&amp;gt; str =&amp;#39;c:\py\code&amp;#39; &amp;gt;&amp;gt;&amp;gt; str &amp;#39;c:\\py\\code&amp;#39; &amp;gt;&amp;gt;&amp;gt; print(str) c:\py\code raw字符 如果要使字符串中的转义不生效，可以使用raw字符串来解决问题。如果字母r（大写或小写）出现在字符串的第一引号的前面，它将会关闭转义机制。这个结果就是Python会将反斜杠作为常量来保持，就像输入的那样。
&amp;gt;&amp;gt;&amp;gt; a=&amp;#39;d:\new\test.py&amp;#39; &amp;gt;&amp;gt;&amp;gt; print(a) d: ew est.py &amp;gt;&amp;gt;&amp;gt; a=r&amp;#39;d:\new\test.py&amp;#39; &amp;gt;&amp;gt;&amp;gt; print(a) d:\new\test.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/08-%E5%88%97%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/08-%E5%88%97%E8%A1%A8/</guid><description>Python的列表对象是这个语言提供的最通用的序列。列表是容器类型，存储的是任意类型的对象的有序集合。
与字符串不同的是，列表没有固定的大小，其大小是可变的，是一个可变对象，支持原处修改，修改列表后不会创建一个新的列表。列表中存储的是元素的引用，修改列表修改的是引用，而不是修改的对象。
列表的表达式符号为中括号（[ ]），通过index和切片能够访问和修改列表元素。
定义 list = [1,2,3,4,&amp;#39;nihao&amp;#39;,5] #使用[]定义列表。列表可以嵌套 list1=&amp;#39;zhangsan lisi wanger mazi&amp;#39;.split() #使用字符串的方法定义列表 列表的操作与方法 修改 通过索引修改指定的索引的元素： list[2] = 32 通过分片修改指定的分片：分片顾头不顾尾 list[2:4] = [] #删除元素操作，等同于del(list[2:4]) list[2:4] = [&amp;#39;m&amp;#39;,&amp;#39;n&amp;#39;,&amp;#39;x&amp;#39;,&amp;#39;y&amp;#39;] #修改操作 【说明】：切片方法替换的是元素，而不是将切片[2:4]替换成列表
通过del()语句删除指定元素： del(list[2:4]) 通过加号运算连接列表：（注意加号运算符前后要有空格，原列表不变） &amp;gt;&amp;gt;&amp;gt; list1=[&amp;#39;i&amp;#39;,&amp;#39;love&amp;#39;,&amp;#39;you&amp;#39;] &amp;gt;&amp;gt;&amp;gt; list2 = [&amp;#34;hello&amp;#34;,&amp;#34;world&amp;#34;] &amp;gt;&amp;gt;&amp;gt; list3= list1 + list2 &amp;gt;&amp;gt;&amp;gt; print list3 [&amp;#39;i&amp;#39;, &amp;#39;love&amp;#39;, &amp;#39;you&amp;#39;, &amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;] 添加元素：append、extend、insert 1、append(x)：将x对象整体作为一个元素追加到列表中
&amp;gt;&amp;gt;&amp;gt; list=[1,2,3] &amp;gt;&amp;gt;&amp;gt; list [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; list.append(4) &amp;gt;&amp;gt;&amp;gt; list [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; list.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/09-%E5%AD%97%E5%85%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/09-%E5%AD%97%E5%85%B8/</guid><description>字典在其他编程语言中又称之为关联数组或散列表。字典是一种映射（mapping）类型（将键映射到值）。字典是Python核心对象集合中的唯一的一种映射，也具有可变性——可以就地改变，并可以随需求增大或减小。和列表一样，字典存储的是对象引用（不是拷贝）。 ​ 字典定义使用表达式符号：花括号{}，通过键（而不是索引/偏移）实现元素存取、修改，无序集合，可变类型的容器，长度可变支持异构和嵌套。
新版本中，字典是有序的，顺序为插入key/value的顺序。
定义 1、使用{}定义字典。格式：{key1:value1,key2:value2&amp;hellip;}
2、dict()构造函数
&amp;gt;&amp;gt;&amp;gt; a = {&amp;#39;one&amp;#39;: 1, &amp;#39;two&amp;#39;: 2, &amp;#39;three&amp;#39;: 3} &amp;gt;&amp;gt;&amp;gt; b = dict(one=1, two=2, three=3) &amp;gt;&amp;gt;&amp;gt; c = dict(zip([&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;three&amp;#39;], [1, 2, 3])) &amp;gt;&amp;gt;&amp;gt; d = dict([(&amp;#39;two&amp;#39;, 2), (&amp;#39;one&amp;#39;, 1), (&amp;#39;three&amp;#39;, 3)]) &amp;gt;&amp;gt;&amp;gt; e = dict({&amp;#39;three&amp;#39;: 3, &amp;#39;one&amp;#39;: 1, &amp;#39;two&amp;#39;: 2}) &amp;gt;&amp;gt;&amp;gt; a == b == c == d == e True zip的用法：
zip(seq1 [, seq2 [...]]) 返回元组列表（python3返回zip对象），如 [(seq1[0], seq2[0] ...), (.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/10-%E5%85%83%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/10-%E5%85%83%E7%BB%84/</guid><description>元组：可以理解为不可改变的列表。
元组是一个容器类型，可以是任意类型的对象的有序集合，通过索引访问其中的元素，不可变对象，长度固定不可变，支持异构(同一个元组中元素类型不同)和嵌套。
元组的特点 任意对象的有序集合 与字符串和列表类似，元组是一个位置有序的对象的集合（也就是其内容维持从左到右的顺序）。与列表相同，可以嵌入到任何类别的对象中。
通过偏移存取 同字符串、列表一样，在元组中的元素通过偏移（而不是键）来访问。它们支持所有基于偏移的操作。例如，索引和分片。
属于不可变序列类型 类似于字符串，元组是不可变的，它们不支持应用在列表中任何原处修改操作。与字符串和列表类似，元组是序列，它们支持许多同样的操作。
固定长度、异构、任意嵌套 因为元组是不可变的，在不生成一个拷贝的情况下不能增长或缩短。另一方面，元组可以包含其他的复合对象（例如，列表、字典和其他元组等），因此支持嵌套。
存储的是对象引用 与列表相似，元组可以看做是对象引用的数组。元组存储指向其他对象的存取点（引用），并且对元组进行索引操作的速度相对较快。
定义 元组定义时，使用括号“( )”表达式，但是也可以省略括号；定义时，最后一个元素后逗号可有可无。
t1=() #定义空元组 t2=(1,) #一般只有一个元素时，逗号不可省略，省略后会认为时一个整数对象 t3=(1,2) #最后一个元素后逗号可有可无 t4=1,2,3,4 #括号可以省略 元组操作与方法 因不支持原处修改，只有count和index两个查询类的方法，没有修改的方法。除此之外，元组和列表的操作基本一致。
tuple.count(value) 返回value出现的次数
tuple.index((value, [start, [stop]]) 返回首次出现value的index。
&amp;gt;&amp;gt;&amp;gt; tuple1=(1,2,3,1,1,2,4,5,6) &amp;gt;&amp;gt;&amp;gt; tuple1.count(1) 3 &amp;gt;&amp;gt;&amp;gt; tuple1.index(2) 1 &amp;gt;&amp;gt;&amp;gt; tuple1.index(1,2,5) 3 &amp;gt;&amp;gt;&amp;gt; tuple1.index(1,4) 4 切片：
运算：
t1+t2 连接操作 t2*3 in not in 说明：元组本身不可变，但是元组中的元素改变会导致元组的显示改变。
为什么要使用元组 为什么我们要用一种类似列表这样的类型，尽管它支持的操作很少？
坦白地说，元组在实际中往往并不像列表这样常用，但是它的关键是不可变性。如果在程序中以列表的形式传递一个对象的集合，它可能在任何地方改变；如果使用元组的话，则不能。也就是说，元组提供了一种完整性的约束，这对于比我们这里所编写的更大型的程序来说是方便的。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/11-%E9%9B%86%E5%90%88set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/11-%E9%9B%86%E5%90%88set/</guid><description>集合是无序排列的可哈希的值（无序且不重复的元素的序列），支持集合关系元算（并集，交集），支持成员关系（in，not in），支持迭代，因为集合是无序的，所以不支持索引、切片。
集合类型：set()，frozenset()
Set类型是可变的，可以使用诸如add()和remove())之类的方法更改内容。由于它是可变的，因此它没有哈希值，也不能用作字典键或另一个集合的元素。 Frozenset类型是不可变的且可哈希化的，创建后无法更改其内容，因此，它可以用作字典键或用作另一个集合的元素。
简单理解：不允许重复的列表，且无序。特点就是：元素不重复、无序
定义 可以使用大括号 { } 或者 set() /frozenset()函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
set(iterable) ：此参数是可迭代的对象，如列表、元组等
&amp;gt;&amp;gt;&amp;gt; s1={11,22,33} &amp;gt;&amp;gt;&amp;gt; s1 {33, 11, 22} &amp;gt;&amp;gt;&amp;gt; set() #定义一个空集合 set() &amp;gt;&amp;gt;&amp;gt; set(&amp;#39;spam&amp;#39;) {&amp;#39;m&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;p&amp;#39;} &amp;gt;&amp;gt;&amp;gt; set([&amp;#39;a&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;m&amp;#39;]) {&amp;#39;m&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;a&amp;#39;} 集合操作与方法 1、添加元素 add(x)：添加一个元素：将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。 s1.add(7) s1.add(&amp;#39;jerry&amp;#39;) update(iterable)：添加迭代对象（列表，元组，字典）的多个元素： s1.update(s2) 2、移除元素 remove(x)：移除指定的元素：如果元素不存在，报错，返回None s1.remove(&amp;#39;jerry&amp;#39;) discard(x)：丢弃指定的元素：如果元素不存在，也不报错，返回None s1.discard(&amp;#39;jerry&amp;#39;) pop( )：移除指定元素，修改后并返回移除的元素。如果未指定x，则随机删除一个元素 s1.pop(&amp;#39;jerry&amp;#39;) clear()清除所有元素： s1.clear() 3、操作 len(s) 计算元素个数</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/12-%E6%96%87%E4%BB%B6file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/12-%E6%96%87%E4%BB%B6file/</guid><description>文件对象是Python代码对电脑上外部文件的主要接口。虽然文件是核心类型，但是它有些特殊：没有特定的常量语法创建文件。要创建一个文件对象，需调用内置的open()函数以字符串的形式传递给它一个外部的文件名以及一个处理模式的字符串。例如，创建一个文本输出文件，可以传递其文件名以及'w'处理模式字符串以写数据。 ​ python操作文件步骤：打开文件&amp;ndash;&amp;gt; 操作文件&amp;ndash;&amp;gt;关闭文件
​ 文件对象：可迭代对象。python中的文件对象是一个基于行的可迭代对象。当调用open()函数时，python会创建一个迭代器，从文件中每次读入一行数据。迭代器中的每一个元素都是一个字符串对象，且字符串含有行尾的’\n’，可以对这些元素使用字符串的方法进行处理。
打开文件open() open(name[,mode,bufsize,encoding=])用于打开文件或创建文件。open方法返回的是一个文件对象。
name和mode都必须是字符串，name如果使用相对路径，则表示当前工作目录，相对于python代码程序所在目录。
mode：指定文件的打开模式，打开模式限定了可以对文件进行的操作。默认为“r”。
bufsize：定义输出缓存
0表示无输出缓冲，直接写入文件；(只能在b模式下使用) 1表示使用缓冲；通常指只缓冲一行数据（） 负数表示使用系统默认设置；默认值-1 正数表示使用近似指定大小的缓冲（指定使用块缓冲的字节大小） encoding=&amp;lsquo;utf-8&amp;rsquo; ：默认选项，文件默认是以二进制形式存储的，python会将最先读取的二进制之自动转换为encoding指定的编码，默认为utf-8。注意，如果对文件进行写操作，需要显示指定encoding=&amp;lsquo;utf-8&amp;rsquo;。
mode详解： 基本mode： 基本mode： r： 只读，以&amp;#39;r&amp;#39;处理模式打开文件，缺省的默认处理模式 open(&amp;#39;/var/log/message.log&amp;#39;,&amp;#39;r&amp;#39;) open(&amp;#39;/tmp/test.txt&amp;#39;) w： 只写（不可读），如果文件不存在，自动创建；如果文件存在，则先清空内容 x ：排他。只写（不可读），如果文件不存在，自动创建；如果文件存在，则报错（不是清空） a： 追加（不可读），如果文件不存在，自动创建；如果文件存在，则追加内容。注意：a模式打开文件时，游标会处于末尾位置，之后调整seek()，游标会根据seek调整，但是写的时候无论如何游标处于何处，都会先移动到文件末尾处，然后追加写（a+亦如此）。 其他mode： +：更新。在模式后使用，“+”表示同时支持输入、输出操作，如r+（以r模式打开文件，可以读写）、w+（以w模式打开文件（清空内容），可以读写）、x+、a+ r+：打开时，指针在0位置（文件开始）。如：f = open(&amp;#39;aa.txt&amp;#39;,&amp;#39;r+&amp;#39;,encoding=&amp;#39;utf-8&amp;#39;) 直接读：0开始；直接写：0开始 读后再写：会以追加的方式写，如果想要在指针位置开始写，手动seek(f.tell())。例如seek(0,2)从末尾开始写。 w+：打开时，w会先清空内容后指针置为0，再进行其他操作。 x+：同w+，只不过有判断文件是否存在的附加功能。 a+：打开时，指针移动到最后。此时无论如何调整seek()都是无效的，写的时候都是追加的方式在文件末尾处写。 b：二进制模式，在模式后使用“b”表示以二进制方式打开，如rb、rb+，注意此时不能指定encoding。需要注意的是：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型。 t：文本模式(默认值) ​ mode总结：一般都是用’r+’或者’rb+’，因为r+比w更加安全，不会清空文件内容；r+比a更加灵活，因为a模式使用seek无论调节写入的位置，只能在末尾处追加。
文件操作与方法 文件关闭 file.close()
文件读取 file. read([size]) file.readline([size]) file.readlines() next(file)或for循环 file. read([size]) 从文件指针处读取size个字符（如果以“b”方式打开，读取单位是“字节byte”），如果size为负数或者省略，则一直读取到EOF(文件末尾)。
它通常用于读取整个文件内容放到一个字符串变量中（内存），将读取到的字符以字符串的形式返回。无论文件内存储存的是什么数据类型，文件的内容的类型都是字符串。在file.close()之前，每读取一次，指针就会变动一次，第二次读取会在第一次读取后的指针位置开始。指针位置通过tell()获取，通过seek()调整。
file.readline([size]) 每次只读取文件的一行（从指针处开始至行尾，包括\n换行字符），将读取到的一行内容放到一个字符串变量中。
通常比 file.readlines()慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用.readline()。size指定读取当前行的多少个字符（从指针处开始，最多读取至该行的末尾）
&amp;gt;&amp;gt;&amp;gt; f1=open(&amp;#39;/etc/passwd&amp;#39;,&amp;#39;r+&amp;#39;) &amp;gt;&amp;gt;&amp;gt; f1.readline() root:x:0:0:root:/root:/bin/bash &amp;gt;&amp;gt;&amp;gt; f1.readline() #指针指向了下一行 bin:x:1:1:bin:/bin:/sbin/nologin file.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/13-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/13-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description>流程控制 三大流程控制语句：
(1) 顺序控制：程序从上到下逐行的执行，中间没有任何判断和跳转。
(2) 分支控制
(3) 循环控制
说明：控制语句可以使用相互嵌套。
顺序结构 顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构,按照代码的先后顺序，依次执行,程序中大多数的代码都是这样执行的
分支结构 if条件语句 语法格式：
if 条件表达式1: 语句1/语句块1 elif 条件表达式2: 语句2/语句块2 . . . elif 条件表达式n: 语句n/语句块n [else: 语句n+1/语句块n+1 ] 在False、0、0.0、空值None、空序列对象（空列表、空元祖、空集合、空字典、空字
符串）、空range 对象、空迭代对象等情况下，条件表达式的值为False，其他条件为True。
示例：
score = int(input(&amp;#34;请输入0-100 之间的整数：&amp;#34;)) grade = &amp;#39;&amp;#39; if score&amp;gt;100 or score&amp;lt;0: score = int(input(&amp;#34;输入错误！请重新输入&amp;#34;)) else: if score&amp;gt;=90: grade = &amp;#34;A&amp;#34; elif score&amp;gt;=70: grade = &amp;#39;B&amp;#39; elif score&amp;gt;=60: grade = &amp;#39;C&amp;#39; else: grade = &amp;#39;D&amp;#39; print(&amp;#34;分数为{0},评级为{1}&amp;#34;.format(score,grade)) 循环结构 for-in循环 for循环提供了python中最强大的循环结构（for循环是一种迭代循环机制，而while循环是条件循环，迭代即重复相同的逻辑操作，每次操作都是基于上一次的结果，而进行的）</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/13-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/13-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>通过内置函数实现类型转换，转换函数会创建新的对象
数字转换为字符串 str() ：输出与print一致，是以一种更加易读的方式显示
repr()
format()
&amp;gt;&amp;gt;&amp;gt; str(&amp;#39;55&amp;#39;) &amp;#39;55&amp;#39; &amp;gt;&amp;gt;&amp;gt; repr(&amp;#39;55&amp;#39;) &amp;#34;&amp;#39;55&amp;#39;&amp;#34; 字符串转换为数值型 int() 将字符串转换为数字
float() 将字符串转换为数字
字符串转序列(列表、元组、集合) 以下三个内置函数不仅仅针对于string，可以是任意的iterable对象
list(iterable)
tuple(iterable)
set(iterable)
&amp;gt;&amp;gt;&amp;gt; str = &amp;#34;hello&amp;#34; &amp;gt;&amp;gt;&amp;gt; list(str) [&amp;#39;h&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;] &amp;gt;&amp;gt;&amp;gt; tuple(str) (&amp;#39;h&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;) &amp;gt;&amp;gt;&amp;gt; set(str) {&amp;#39;o&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;e&amp;#39;} 字符串转对象 eval()：执行字符串表达式。例如将字符串转换为对象，eval能够将字符串当作可执行的程序代码，执行字符串表示的所有的python表达式
&amp;gt;&amp;gt;&amp;gt; eval(&amp;#39;[1, 2, 3]&amp;#39;) [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; eval(&amp;#34;{&amp;#39;a&amp;#39;: 1, &amp;#39;b&amp;#39;: 2}\n&amp;#34;) {&amp;#39;a&amp;#39;: 1, &amp;#39;b&amp;#39;: 2} 元组列表转字典 dict(list)：将键值对的元组构成的列表转换为字典。其中list为(key,value)的元组列表
&amp;gt;&amp;gt;&amp;gt; dict([(&amp;#39;a&amp;#39;,1),(&amp;#39;b&amp;#39;,2),(&amp;#39;c&amp;#39;,3)]) {&amp;#39;a&amp;#39;: 1, &amp;#39;c&amp;#39;: 3, &amp;#39;b&amp;#39;: 2} 整数转不同进制 hex()：将整数转换为16进制字串</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/14-%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/14-%E5%87%BD%E6%95%B0/</guid><description>一、函数定义 def 函数名(参数…): ... 函数体 ... 返回值 说明：
def：表示定义函数的关键字。def语句将创建一个函数对象并将其赋值给一个变量名，这个变量名我们一般称之为“函数名“。 函数名：函数的名称，定义函数后根据函数名调用函数。 函数体：函数中进行一系列的逻辑计算，如：发送邮件、计算出 [11,22,38,888,2]中的最大数等&amp;hellip; 参数：为函数体传递的数据，位于括号内，可省略。 返回值：当函数执行完毕后，可以给调用者返回数据。return关键字定义返回值，缺省返回None。注意，一旦遇到return语句，就会结束函数的执行跳出函数，即函数内部return语句后面函数体的其他部分不再执行。 局部变量：函数体中定义的变量为局部变量，作用域为整个函数体。建议局部变量使用小写。 全局变量：函数体外定义的变量为全局变量，所有的函数中都继承此变量值。如果函数中定义了与全局的变量同名的局部变量，则以局部变量优先生效。Python中，可以理解为同名的全局变量和局部变量为两个不同的变量，局部变量并没有修改全局变量的值。如果要让局部变量修改同名的全局变量，需要使用global关键字对函数体内的变量进行全局声明。例如global aa；aa=‘hello’，此时局部变量aa=‘hello’就会修改全局变量aa的值。建议全局变量使用大写。（这点与shell不同，shell在函数中定义的变量是本地变量，shell中的本地变量的作用域是整个shell脚本，而不是整个函数，不过可以使用local声明为局部变量，使之的作用域为整个函数） 二、函数的执行过程 1、函数定义在代码执行过程中是如何执行的？
当Python运行到def语句并执行了def语句时，它将会创建一个新的函数对象，封装这个函数的代码到这个对象中并将这个对象并赋值给变量名。python在运行函数定义代码时，只运行了def语句，然后将主体代码封装在该函数对象中。主体代码是在函数调用的时候才运行的。
2、在def运行之后，我们就可以调用函数了。如何调用？
可以在程序中通过在函数名后增加括号调用（运行）这个函数。括号中可以包含一个或多个对象参数，这些参数将会传递（赋值/引用）给函数头部的参数名。参数传递之后，函数的主体就开始运行。
三、函数参数 实参赋值给形参(重点) 1、形参与实参： 函数定义中，形参定义顺序：def func(value,key=value,*args,kw-only[=value],**kwargs)，Python的函数支持位置参数、默认值参数、任意参数、关键字参数。
在函数调用中，使用的最复杂的实参也就是func(value,key=value,*args,**kwargs)这个样子，虽然复杂但是最终可以解析为有两类参数：位置参数和关键字参数。因为*args本质也是位置参数，只不过它需要事先进行参数解包，解包后变成了位置参数；同理，**kwargs会被分解成关键字参数。在*args和**kwargs进行完参数解包之后，原先所有的参数就只有位置参数和关键字参数这两种了。
2、具体的赋值过程： 1、参数解包：我们首先将实参中的*args,**kwargs两种参数进行参数解包，*args会解包成一个value的列表并会append到原先的value列表中组合成一个新的value列表；**kwargs解包成key=value的列表。此时解包完成后，最终形成一个只有value,key=value两种形式的实参列表。
2、按顺序赋值：将第一步中的实参列表按照如下形参顺序进行赋值：kw-only,value,key=value,*args,**kwargs。在以上赋值过程中，我们先对kw-only进行赋值，然后拿实参的位置参数对value依次赋值，待形参中所有的有名称参数value都被赋值完后，剩余的位置参数会被组成一个名称为args的元组(*args，名为args的元组)；再然后拿所有的关键字参数根据key值对key进行赋值，也会将赋值后剩余的key=value组合成一个名为kwargs的字典(**kwargs)。
参数使用细节 实参中，多个位置参数之间是有先后顺序的，这也是他们被称之为位置参数的原因；多个关键字参数之间是没有先后顺序的，它们是通过key进行定位；但是所有的位置参数都必须在关键字参数之前。 Keyword-Only参数在调用中只能使用关键字语法来传递。定义时要定义在*args和**kwargs之间，调用时新版本对其位置不再限制。不过建议与定义时的顺序一致。Keyword-Only参数也分为有默认值和无默认值 无论是def中还是函数调用中，value都要在key=value之前。 Keyword-Only参数在调用中只能使用关键字语法来传递。定义时要定义在*args和**kwargs之间，调用时新版本对其位置不再限制。不过建议与定义时的顺序一致。 参数使用示例 1、普通参数（非任意参数）： def f(a,b,c): print(a,b,c) f(1,2,3) #位置参数，顺序匹配。精确地传递和函数头部参数名一样多的参数 f(b=2,c=3,a=1) #关键字参数，允许通过变量名进行匹配，而不是通过位置，所以位置可乱序\。精确地传递和函数头部参数名一样多的参数 f(1,c=3,b=2) #位置参数+关键字参数：位置参数必须位于关键字参数之前 def f(a,b,c=5,d=6): #默认参数：在所有的参数匹配之后，没有被匹配的参数将使用默认值。所以默认参数要在普通参数之后 print(a,b,c,d) f(1,2,3,4) #1 2 3 4 f(1,2) #1 2 5 6 f(1,d=4,b=2) #1 2 5 4 f(b=2,a=1) #1 2 5 6 f(c=3,b=2,a=1) #1 2 3 6 2、任意形参（又称：收集参数） def f(*args): #在函数定义中使用，将收集不匹配的位置参数定义在一个元组中 print(args) f() #() f(1) #(1,) f(1,2,3,4) #(1, 2, 3, 4) def f(**kwargs): #收集不匹配的关键字参数，将这些关键字参数传递给一个新的字典，例如本例的字典kwargs。在函数中可以对改字典进行调用 print(kwargs) kwargs[&amp;#39;a&amp;#39;]=2 #对字典kwargs中的建&amp;#39;a&amp;#39;进行调用（赋值） f() #{} f(a=1,b=2) #{&amp;#39;a&amp;#39;: 1, &amp;#39;b&amp;#39;: 2} def f(a,*args,**kwargs): #一般参数(普通参数+默认字参数) + *参数 + **参数。注意顺序 print(a,args,kwargs) f(1,2,3,4) #1 (2, 3, 4) {} f(1,2,3,b=4,c=5) #1 (2, 3) {&amp;#39;b&amp;#39;: 4, &amp;#39;c&amp;#39;: 5} f(1,2,3,a=4,b=5,c=6) #TypeError: f() got multiple values for argument &amp;#39;a&amp;#39;。a=1之后又赋值a=4导致错误 def f(a,d=5,*args,**kwargs): #在一般参数（包括普通参数和默认参数）匹配之后，将剩余的参数赋值给*args和**kwargs print(a,args,kwargs,d) f(1) #1 () {} 5 f(1,2,3,4) #1 (3, 4) {} 2 f(1,2,3,b=4,c=5) #1 (3,) {&amp;#39;b&amp;#39;: 4, &amp;#39;c&amp;#39;: 5} 2 3、任意实参（又称：参数解包） def f(a,b,c,d): print(a,b,c,d) args=[1,2,3,4] error_args=[1,2,3,4,5] kwargs={&amp;#39;a&amp;#39;:1,&amp;#39;b&amp;#39;:2,&amp;#39;c&amp;#39;:3,&amp;#39;d&amp;#39;:4} f(*args) #1 2 3 4 ==&amp;gt;注意args元素个数要与函数的参数个数相同 f(**kwargs) #1 2 3 4 f(*error_args) #TypeError: f() takes 4 positional arguments but 5 were given f(*(1,2),**{&amp;#39;c&amp;#39;:3,&amp;#39;d&amp;#39;:4}) #1 2 3 4 f(1,*(1,2),**{&amp;#39;d&amp;#39;:4}) #1 1 2 4 f(1,*(2,3),d=4) #1 2 3 4 f(1,d=4,*(2,),**{&amp;#39;c&amp;#39;:3}) #1 2 3 4 f(1,*(2,),d=4,**{&amp;#39;c&amp;#39;:3}) #1 2 3 4 ==&amp;gt; 匹配顺序：位置参数&amp;gt;关键字参数&amp;gt;任意参数（*参数+**参数） # 一个实用的例子： def tracer(function, *pargs, **kargs): print(&amp;#39;calling:&amp;#39;, function.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/14.1-%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/14.1-%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>此篇摘自网络
装饰器本质上就是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象，并把这个函数对象赋值给被修饰的函数名。
装饰器模板 先上一个如何定义装饰器的模板：
def FUNC_NAME(func): def wrapper(*args,**kwargs): # 需要修改的代码，为被修饰的函数增加功能 #logging.warning(&amp;#34;{} is running&amp;#34;.format(func.__name__)) return func(*args,**kwargs) return wrapper 如果要在被修饰函数执行后增加一些功能，可以使用如下方法：
def FUNC_NAME(func): def wrapper(*args,**kwargs): tmp = func(*args,**kwargs) # 需要修改的代码，为被修饰的函数增加功能 #logging.warning(&amp;#34;{} is finish&amp;#34;.format(func.__name__)) return tmp return wrapper 如何使用：在被修饰函数之前使用@FUNC_NAME
@FUNC_NAME def foo(): pass 装饰器的引入 讲 Python 装饰器前，我想先举个例子，虽有点污，但跟装饰器这个话题很贴切。
每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没办法为我们防风御寒，咋办？我们想到一个办法就是把内裤改造一下，让他变得更厚更长，这样一来，它不仅有遮羞功能，还能提供保暖，不过有个问题，这个内裤被我们改造成长裤后，虽然还具有遮羞功能，但本质上他不再是一条真正的内裤了。于是聪明的人们发明了长裤，在不修改内裤的前提下，直接将长裤套在了内裤的外面，这样内裤还是内裤，有了长裤也可以防风御寒了。装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。
谈装饰器前，还要先要明白一件事，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数，例如：
def foo(): print(&amp;#34;foo&amp;#34;) def bar(func): func() bar(foo) 正式回到我们的主题。装饰器本质上是一个Python函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。
先来看一个简单例子，虽然实际代码可能比这复杂很多：
def foo(): print(&amp;#34;i am foo&amp;#34;) 现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：
def foo(): print(&amp;#34;i am foo&amp;#34;) logging.info(&amp;#34;foo is running&amp;#34;) 如果函数bar()、bar2()也有类似的需求，怎么做？再写一个logging在bar函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门处理日志，日志处理完之后再执行真正的业务代码：</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/14.2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/14.2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</guid><description> 迭代器 迭代器对象是支持迭代器协议的对象.
在Python中，支持迭代器协议就是实现对象的__iter__()和__next__()方法。其中__iter__()方法(或内置函数iter())返回迭代器对象本身self；__next__()方法(或内置函数next())返回容器的下一个元素，在结尾时引发StopIteration异常。
li=[1,2,3] it=li.__iter__() print(it.__next__()) print(it.__next__()) print(next(it)) 迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器有两个基本的方法：iter() 和 next()。对于可迭代对象，可以使用内建函数iter()来获取它的迭代器对象，例如iter1=iter([1,2,3])；通过next()函数来获取下一个元素，例如next(iter1)。可迭代的对象（例如字符串，列表或元组对象）都可用于创建迭代器。
生成器 生成器：一个使用yeild代替return的函数
在Python中，使用了yield的函数被称为生成器（generator）。生成器函数可以通过常规的def语句来定义，但是返回值不是用return返回，而是用yield一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。
跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。调用一个生成器函数，返回的是一个迭代器对象。
在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield后面的表达式的值，并在下一次执行next(x)方法时从当前位置继续运行。例如r=xfunc()，会获取一个生成器r。然后执行r.__next__() 方法时，会执行生成器函数中的代码到第一个yeild，并返回yeild后面的表达式值，当再次执行r.__next__() 方法时，会从yeild后面语句继续执行，直到下一个yeild执行返回yeild后面的表达式值（或引发StopIteration异常）。
def yield_test(n): for i in range(n): yield call(i) print(&amp;#34;i=&amp;#34;, i) # 做一些其它的事情 print(&amp;#34;do something.&amp;#34;) print(&amp;#34;end.&amp;#34;) def call(i): return i * 2 # 使用for循环 for i in yield_test(5): print(i, &amp;#34;,&amp;#34;)</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>类的定义 class CLASS_NAME: #class语句，产生类对象，并把类对象赋值给class关键字后的CLASS_NAME变量名，这点跟def语句类似。类名称后的括号可有可无,继承父类时，才有。 def __init__(self,arg1,arg2...): #构造方法 self.attr1=arg1 ... self.attr2=argument1 #普通字段，保存在对象中 ... def func1(self,arg1,arg2...):　#定义类的方法，注意固定参数：self参数 pass def func2(self,arg1,arg2...): #普通方法，保存在类中 pass 在class语句内，任何赋值语句都会产生类属性或类方法，例如def语句、attr=attrbute等。这里的赋值语句包括=运算符、def语句等 类是一个命名空间，其内保存了类属性、类方法。 self参数的作用:
对象是由对应的类实例化而来的,当对象调用相应类的方法时，会将对象自身作为一个参数传递给类中的self参数，此参数由python内部自动传递，无需手动赋值。通俗地将：self参数指代类实例化后产生的那个实例对象。
易错点：
class asd: def ad(self,a,b): return self.a + self.b #AttributeError: &amp;#39;asd&amp;#39; object has no attribute &amp;#39;a&amp;#39;. self.a是使用前没有定义（赋值） a = asd() c = a.ad(1,2) print(c) # 正确方式： class asd: def ad(self,a,b): self.a=a self.b=b return self.a + self.b #以上3行或改为：return a+b a = asd() c = a.ad(1,2) print(c) 类的实例化 obj=CLASS_NAME(arg1,arg2.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/16-%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%96%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/16-%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%96%AD%E8%A8%80/</guid><description>什么是异常？ Python的运行时错误称作异常。Python异常是一个对象，表示错误或意外发生。
异常分为：
语法错误：软件的结构上有错误而导致不能被解释器解释或不能被编译器编译。 逻辑错误：由于不完整或不合法的输入所致，也可能是逻辑无法生成、计算或输出结果需要的过程无法执行等。 Python的异常默认处理方式则是：终止应用程序，并打印提示信息；
当Python检测到一个错误时，将触发一个异常。Python可以通过异常传导机制传递给一个异常对象，发出一个异常情况出现的信号。Python程序员也可以在代码中手动触发异常来实现控制流的控制。
异常捕获 常用格式： try: pass # 主代码块 except Exception as e: pass # 任何异常时，执行该块 …… #try-except语句执行完后，继续执行其他语句 其他格式： try-except：except可多个 try-finally： try-except-else： try-except-finally： try-except-else-finally： 完整格式： try: pass #主代码块,遇到异常，中断当前代码段，跳转到except except KeyError as e: pass # KeyError异常时，执行该块 ...省略其他的except，依次捕获... except Exception as e: pass # Exception异常时，执行该块。等同于except:捕获一切异常 except: #捕获一切异常 pass #Other exception handle，except块是可选项，如果没有提供，该exception将会被提交给python进行默认处理，默认处理方式则是终止应用程序并打印提示信息； else: pass # 没有异常时，执行该块 finally: pass # 无论异常与否，最终执行该块 pass 主动触发异常 对异常进行捕获处理：
try: pass raise Exception(&amp;#39;错误了。。。&amp;#39;) #创建Exception对象(封装了错误信息) except Exception as e: print(e) #后面的语句继续执行 对异常不进行捕获处理:</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/17-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/17-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid><description>编程中（不使用线程时），一个进程中只有一个线程（主线程）来进行代码的解析执行。在使用threading时，主线程会创建并调用子线程来进行某些代码的执行，实现多个任务的并行执行。
多线程：threading模块 进程与线程的区别
创建线程 threading.Thread(target=None, name=None, args=(), kwargs={}, daemon=false) ​ target : 函数
​ name：是线程名称。默认情况下，唯一名称的格式为“ Thread-N”，其中N是一个小十进制数字。
​ args、kwargs：函数的参数
​ daemon：是否设置线程为守护线程。如果是守护线程，主线程可以不再理会它是否执行完毕。
import threading import time def f1(): pass def f2(a1,a2,id): time.sleep(2) f1() print(&amp;#34;t{}_end&amp;#34;.format(id),&amp;#39;@&amp;#39;,time.ctime()) print(&amp;#34;t1_start @{}&amp;#34;.format(time.ctime())) t1=threading.Thread(target=f2,args=(111,222,1)) #创建一个线程,注意args参数是一个元组 t1.start() #运行线程 print(&amp;#34;t2_start @{}&amp;#34;.format(time.ctime())) t2=threading.Thread(target=f2,args=(111,222,2)) t2.start() print(&amp;#34;t3_start @{}&amp;#34;.format(time.ctime())) t3=threading.Thread(target=f2,args=(111,222,3)) t3.start() print(&amp;#34;master finish @{}&amp;#34;.format(time.ctime())) 以上示例中，主线程启动了3个子线程，在默认值t.daemon=false的情况下，主线程会等待所有的线程都执行完毕退出后再退出。
什么是守护线程？ 避免使用thread模块而使用threading模块的一个原因是该模块不支持守护线程这个概念。即当主线程退出时，所有子线程都将终止，不管它们是否仍在工作。如果你不希望发生这种行为，就要引入守护线程的概念了。
threading 模块支持守护线程，其工作方式是：守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。
如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。该标记值为真时，表示该线程是不重要的，或者说该线程只是用来等待客户端请求而不做任何其他事情。
整个Python 程序（可以解读为：主线程）将在所有普通线程(非守护线程)退出之后才退出，换句话说，就是没有剩下存活的普通线程时。
如何设置子线程为守护线程？
定义时设置：t1=threading.Thread(target=fun,args=(999,),daemon=True)
运行前设置：
t1=threading.Thread(target=fun,args=(999,)) t1.daemon=True 或 t1.setDaemon(True) t1.start() 要将一个线程设置为守护线程，需要在启动线程之前执行如下赋值语句：thread.daemon = True（调用~~thread.setDaemon(True)~~的旧方法已经弃用了）。同样，要检查线程的守护状态，也只需要检查这个值即可（对比过去调用thread.isDaemon()的方法）。一个新的子线程会继承父线程的守护标记。
示例：主线程不等待子线程
import threading import time def fun(id): print(&amp;#34;start_sleep:&amp;#34;,id,time.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/18-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/18-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>本章节转载自Python之路【第六篇】：socket
socket编程 socket概述 socket通常也称作&amp;quot;套接字&amp;quot;，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过&amp;quot;套接字&amp;quot;向网络发出请求或者应答网络请求。
socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）
模块socket和file的区别 file模块是针对某个指定文件进行【打开】【读写】【关闭】 socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】 socket模块 sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)
参数一：地址簇(地址家族) socket.AF_INET ：IPv4（默认） socket.AF_INET6 ： IPv6 socket.AF_UNIX ：只能够用于单一的Unix系统进程间通信 参数二：类型 socket.SOCK_STREAM：流式socket , for TCP （默认） socket.SOCK_DGRAM：数据报式socket , for UDP socket.SOCK_RAW：原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。 socket.SOCK_RDM：是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。 socket.SOCK_SEQPACKET：可靠的连续数据包服务 参数三：协议 0　（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议 sk.bind(address)
s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。一般用于server端
sk.listen(backlog)
开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。例如：backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5。这个值不能无限大，因为要在内核中维护连接队列。一般用于server端
sk.accept()
以阻塞的形式，接受client连接，并返回（conn,address）。其中conn是新的套接字对象，可以用来接收和发送数据；address是连接客户端的地址。
总结：接收TCP 客户的连接（阻塞式）等待连接的到来。
sk.connect(address)
连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。与sk.accept()成对出现。一般用于client端。
sk.sendall(string[,flag])
将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。
内部通过递归调用send，将所有内容发送出去。
sk.recv(bufsize[,flag])
接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。
实例：聊天机器人 server端：
import socket sk=socket.socket() #创建套接字对象 sk.bind((&amp;#39;127.0.0.1&amp;#39;,9999,)) #套接字绑定ip:port sk.listen(5) #监听套接字，数字代表最大并发请求数 while True: conn,address=sk.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/19-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/19-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</guid><description>参考：https://www.cnblogs.com/zhbzz2007/p/6158125.html
利用contextlib创建一个上下文管理器 Python 2.5 不仅仅添加了with语句，它也添加了contextlib模块。这就允许我们使用contextlib的contextmanager函数作为装饰器，来创建一个上下文管理器。让我们尝试着用它来创建一个上下文管理器，用于打开和关闭文件。
from contextlib import contextmanager @contextmanager def file_open(path): try: f_obj = open(path,&amp;#34;w&amp;#34;) yield f_obj except OSError: print(&amp;#34;We had an error!&amp;#34;) finally: print(&amp;#34;Closing file&amp;#34;) f_obj.close() if __name__ == &amp;#34;__main__&amp;#34;: with file_open(&amp;#34;test/test.txt&amp;#34;) as fobj: fobj.write(&amp;#34;Testing context managers&amp;#34;) 在这里，我们从contextlib模块中引入contextmanager，然后装饰我们所定义的file_open函数。这就允许我们使用Python的with语句来调用file_open函数。在函数中，我们打开文件，然后通过yield，将其传递出去，最终主调函数可以使用它。一旦with语句结束，控制就会返回给file_open函数，它继续执行yield语句后面的代码。这个最终会执行finally语句&amp;ndash;关闭文件。如果我们在打开文件时遇到了OSError错误，它就会被捕获，最终finally语句依然会关闭文件句柄。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.1-%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.1-%E6%A8%A1%E5%9D%97/</guid><description>什么是模块？ 在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就可以称之为一个模块（Module）。
使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。每个模块有独立的命名空间，因此相同名字的函数和变量完全可以分别存在不同的模块中，所以，我们自己在编写模块时，不必考虑名字会与其他模块冲突 模块分类 模块分为三种：
内置标准模块（又称标准库）执行help(‘modules’)查看所有python自带模块列表 第三方开源模块，可通过pip install 模块名 联网安装 自定义模块 安装第三方模块 使用软件包管理工具pip/pip3安装 pip3 install requests #安装requests模块 源码安装 Get the Source Code, download the tarball:
$ cd requests $ python setup.py install 或者pip install . 模块导入&amp;amp;调用 import module_a #导入 from module import xx from module.xx.xx import xx as rename #导入后重命令 from module.xx.xx import * #导入一个模块下的所有方法，不建议使用 module_a.xxx #调用 注意：模块一旦被调用，即相当于执行了另外一个py文件里的代码
自定义模块 这个最简单， 创建一个.py文件，就可以称之为模块，就可以在另外一个程序里导入
模块查找路径 发现，自己写的模块只能在当前路径下的程序里才能导入，换一个目录再导入自己的模块就报错说找不到了， 这是为什么？
这与导入模块的查找路径有关
import sysprint(sys.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.10-requests%E6%A8%A1%E5%9D%97%E6%8E%A8%E8%8D%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.10-requests%E6%A8%A1%E5%9D%97%E6%8E%A8%E8%8D%90/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.10-yaml%E6%A8%A1%E5%9D%97-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.10-yaml%E6%A8%A1%E5%9D%97-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.11-configparser%E6%A8%A1%E5%9D%97-cnf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.11-configparser%E6%A8%A1%E5%9D%97-cnf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.12-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.12-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.13-toml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.13-toml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.14-subprocess%E6%A8%A1%E5%9D%97-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.14-subprocess%E6%A8%A1%E5%9D%97-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.15-signal%E6%A8%A1%E5%9D%97-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.15-signal%E6%A8%A1%E5%9D%97-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.16-logging%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.16-logging%E6%A8%A1%E5%9D%97/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.17-psutil%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.17-psutil%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</guid><description>简介 安装 pip安装： 源码安装 系统级别相关的函数 cpu psutil.cpu_times(percpu=False) psutil.cpu_percent(interval=None, percpu=False) psutil.cpu_count(logical=True) psutil.cpu_stats() psutil.cpu_freq(percpu=False) Memory psutil.virtual_memory() psutil.swap_memory() Disks psutil.disk_partitions(all=False) psutil.disk_usage(path) psutil.disk_io_counters(perdisk=False, nowrap=True) Network psutil.net_io_counters(pernic=False, nowrap=True) psutil.net_connections(kind=&amp;lsquo;inet&amp;rsquo;) psutil.net_if_addrs() psutil.net_if_stats() 传感器相关的函数（了解） psutil.sensors_temperatures(fahrenheit=False) psutil.sensors_fans() psutil.sensors_battery() 其他系统信息 psutil.boot_time() psutil.users() 进程级别的函数 相关函数 psutil.pids() psutil.process_iter(attrs=None, ad_value=None) psutil.pid_exists(pid) psutil.wait_procs(procs, timeout=None, callback=None) Process类 class psutil.Process(pid=None) pid ppid() name() exe() cmdline() environ() create_time() as_dict(attrs=None, ad_value=None) parent() status() cwd() username() uids() gids() terminal() nice(value=None) ionice(ioclass=None, value=None) rlimit(resource, limits=None) io_counters() num_ctx_switches() num_fds() num_handles() num_threads() threads() cpu_times() cpu_percent(interval=None) cpu_affinity(cpus=None) cpu_num() memory_info() memory_full_info() memory_percent(memtype=&amp;ldquo;rss&amp;rdquo;) memory_maps(grouped=True) children(recursive=False) open_files() connections(kind=&amp;ldquo;inet&amp;rdquo;) is_running() send_signal(signal) suspend() resume() terminate() kill() wait(timeout=None) Popen类 class psutil.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.18-paramiko%E6%A8%A1%E5%9D%97-ssh%E5%8D%8F%E8%AE%AE%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.18-paramiko%E6%A8%A1%E5%9D%97-ssh%E5%8D%8F%E8%AE%AE%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.19-lxml%E6%A8%A1%E5%9D%97-xpath/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.19-lxml%E6%A8%A1%E5%9D%97-xpath/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.2-os%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.2-os%E6%A8%A1%E5%9D%97/</guid><description>os模块用于提供操作系统级别的操作：主要提供处理文件、目录的方法
http://www.runoob.com/python/os-file-methods.html
执行命令 os.system(&amp;ldquo;bash command&amp;rdquo;) 运行shell命令，直接显示。调用完后自身退出，返回值是脚本的退出状态码。
&amp;gt;&amp;gt;&amp;gt; output=os.system(&amp;#39;ls /&amp;#39;) Applications System Volumes cores etc opt sbin usr Library Users bin dev home private tmp var &amp;gt;&amp;gt;&amp;gt; print(output) 0 file=os.popen(&amp;ldquo;ls&amp;rdquo;) os.popen()可以实现一个“管道pipe”,从这个命令获取的值可以继续被使用。
因为它返回一个文件对象,可以对这个文件对象进行相关的操作（read()、readline()、readlines()、for遍历），对象内容为脚本执行过程中的输出内容。
#获取ntpd的进程id os.popen(&amp;#39;ps -C ntpd | grep -v CMD |awk &amp;#39;{ print $1 }&amp;#39;).readlines()[0] 目录操作 os.getcwd() 获取当前工作目录，即当前python脚本所在目录路径，类似shell的pwd命令
os.chdir(&amp;ldquo;dirname&amp;rdquo;) 改变当前脚本****工作目录****；相当于shell下cd
os.curdir 返回当前目录: (&amp;rsquo;.&amp;rsquo;)，注意是个属性不是方法，所以不带括号。
os.pardir 获取当前目录的父目录字符串名：(&amp;rsquo;..')
os.makedirs(&amp;lsquo;dir1/dir2&amp;rsquo;) 可生成多层递归目录，类似shell中mkdir –p dir1/dir2
os.mkdir(&amp;lsquo;dirname&amp;rsquo;) 生成单级目录；相当于shell中mkdir dirname
os.removedirs(&amp;lsquo;dirname1&amp;rsquo;) 删除非空目录。若目录为空，则删除，并递归到上一级目录，如若也为空，也删除，依此类推。
&amp;gt;&amp;gt;&amp;gt; os.makedirs(&amp;#39;/tmp/a/b/c&amp;#39;) &amp;gt;&amp;gt;&amp;gt; os.removedirs(&amp;#39;/tmp/a/b/c&amp;#39;) #此时，不仅会删除c，也把b和a目录页删除 &amp;gt;&amp;gt;&amp;gt; os.listdir(&amp;#39;/tmp/a&amp;#39;) Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;/tmp/a&amp;#39; os.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.20-platform%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.20-platform%E6%A8%A1%E5%9D%97/</guid><description>平台架构 platform.machine() 返回平台架构。若无法确定，则返回空字符串。
&amp;gt;&amp;gt;&amp;gt; platform.machine() &amp;#39;AMD64&amp;#39; &amp;gt;&amp;gt;&amp;gt; platform.machine() &amp;#39;x86_64&amp;#39; 网络名称（主机名） platform.node() 返回计算机的网络名称(可能未被完全限定！)。如果无法确定该值,则返回空字符串。
#windows &amp;gt;&amp;gt;&amp;gt; platform.node() &amp;#39;office&amp;#39; #linux &amp;gt;&amp;gt;&amp;gt; platform.node() &amp;#39;abcxx&amp;#39; 系统版本 platform.platform(aliased = 0,terse = 0) 如果aliased为True,则该函数将使用不同平台的别名来报告与其常用名称不同的系统名称,例如SunOS将被报告为Solaris。 system_alias()函数用于实现。 将terse设置为True会导致该功能仅返回识别平台所需的绝对最小信息。
&amp;gt;&amp;gt;&amp;gt; platform.platform() &amp;#39;Windows-8.1-6.3.9600-SP0&amp;#39; &amp;gt;&amp;gt;&amp;gt; platform.platform(aliased=True) &amp;#39;Windows-8.1-6.3.9600-SP0&amp;#39; &amp;gt;&amp;gt;&amp;gt; platform.platform(aliased=True,terse=True) &amp;#39;Windows-8.1&amp;#39; &amp;gt;&amp;gt;&amp;gt; platform.platform(aliased=True,terse=False) &amp;#39;Windows-8.1-6.3.9600-SP0&amp;#39; #linux &amp;gt;&amp;gt;&amp;gt; platform.platform() &amp;#39;Linux-2.6.32-642.13.1.el6.x86_64-x86_64-with-centos-6.8-Final&amp;#39; 处理器名称 platform.processor() 返回处理器名称。
&amp;gt;&amp;gt;&amp;gt; platform.processor() &amp;#39;Intel64 Family 6 Model 60 Stepping 3, GenuineIntel&amp;#39; #linux &amp;gt;&amp;gt;&amp;gt; platform.processor() &amp;#39;x86_64&amp;#39; 系统名称 platform.system() 返回系统/操作系统名称,例如“Linux”,“Windows”或“Java”。如果无法确定该值,则返回空字符串。
&amp;gt;&amp;gt;&amp;gt; platform.system() &amp;#39;Windows&amp;#39; #linux &amp;gt;&amp;gt;&amp;gt; platform.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.21-PrettyTable%E6%A8%A1%E5%9D%97-%E8%A1%A8%E6%A0%BC%E8%BE%93%E5%87%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.21-PrettyTable%E6%A8%A1%E5%9D%97-%E8%A1%A8%E6%A0%BC%E8%BE%93%E5%87%BA/</guid><description>https://blog.csdn.net/xc_zhou/article/details/81458740</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.22-rich%E6%A8%A1%E5%9D%97-%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.22-rich%E6%A8%A1%E5%9D%97-%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description>https://blog.csdn.net/qq_43954124/article/details/112772262</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.23-pexcept%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.23-pexcept%E6%A8%A1%E5%9D%97/</guid><description>一：pexpect简介 https://blog.csdn.net/pcn01/article/details/104993742/
以下演示python版本：python3.7.4
pexpect官方文档：pexpect链接
Expect 程序主要用于人机对话的模拟，就是那种系统提问，人来回答 yes/no ，或者账号登录输入用户名和密码等等的情况。因为这种情况特别多而且繁琐，所以很多语言都有各种自己的实现。最初的第一个 Expect 是由 TCL 语言实现的，所以后来的 Expect 都大致参考了最初的用法和流程，整体来说大致的流程包括：
运行程序
程序要求人的判断和输入
Expect 通过关键字匹配
根据关键字向程序发送符合的字符串
TCL 语言实现的 Expect 功能非常强大，我曾经用它实现了防火墙设备的完整测试平台。也因为它使用方便、范围广，几乎所有脚本语言都实现了各种各样的类似与Expect的功能，它们叫法虽然不同，但原理都相差不大
pexpect 是 Python 语言的类 Expect 实现。从我的角度来看，它在功能上与 TCL 语言的实现还是有一些差距，比如没有buffer_full 事件、比如没有 expect before/after 事件等，但用来做一般的应用还是足够了。
二：基本使用流程 pexpect 的使用说来说去，就是围绕3个关键命令做操作：
首先用 spawn 来执行一个程序 使用 expect 来等待指定的关键字，这个关键字是被执行的程序打印到标准输出上面的 最后当发现这个关键字以后，根据关键字用 send 方法来发送字符串给这个程序 第一步只需要做一次，但在程序中会不停的循环第二、三步来一步一步的完成整个工作。掌握这个概念之后 pexpect 的使用就很容易了。当然 pexpect 不会只有这 3 个方法，实际上还有很多外围的其他方法
# 在本机执行命令，并输出命令执行结果 import pexpect child = pexpect.spawn(&amp;#39;ls -l&amp;#39;) child.expect(pexpect.EOF) result = child.before.decode() print(result) 三：API使用 3.1 spawn类 spawn() 方法用来执行一个程序，它返回这个程序的操作句柄，以后可以通过操作这个句柄来对这个程序进行操作。spawn类的__init__方法如下：</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.3-sys%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.3-sys%E6%A8%A1%E5%9D%97/</guid><description>sys模块主要提供跟python解释器相关的操作。
sys.argv 脚本参数列表，argv[0]（第一个元素）是脚本路径（程序本身的路径）
sys.path 模块搜索路径; path[0]是脚本所在目录。
import os,sys sys.path.append(os.path.dirname(os.path.dirname(__file__))) 模块搜索路径：
lib是内置模块；site-packages为第三方模块。顺序搜索，直到找到的第一个路径。
sys.modules 已经加载的模块
sys.stdout.write() 标准输出，print（）
sys.stdin.write() 标准输入，input（）
#打印进度条 import time import sys for i in range(101): sys.stdout.write(&amp;#39;\r&amp;#39;) #不换行 sys.stdout.write(&amp;#39;%s%% [%s%s]&amp;#39;%(i,&amp;#39;=&amp;#39;*i,&amp;#34; &amp;#34;*(100-i))) sys.stdout.flush() time.sleep(0.1)</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.4-shutil-zipfile-tarfile%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.4-shutil-zipfile-tarfile%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid><description>【说明：未同步word文档】 shutil是shell utility的缩写，实现了在Python中实现文件复制、移动、压缩、解压等高级功能，是Python的系统模块，不需要额外安装。
shutil.copyfile( src, dst) 从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉，相当于linux的cp -rf
shutil.copy( src, dst) 复制一个文件到一个文件或一个目录
shutil.copy2( src, dst) 在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，相当于linux的cp –p。也可用于rename操作。
shutil.copymode( src, dst) 只是会复制其权限其他的东西是不会被复制的
shutil.copystat( src, dst) 复制权限、最后访问时间、最后修改时间
shutil.copytree( olddir, newdir, True/Flase) 把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接
shutil.move( src, dst) 移动文件或重命名,相当于linux的mv
shutil.rmtree( src ) 递归删除一个目录以及目录内的所有内容
#文件、文件夹的移动、复制、删除、重命名 #导入shutil模块和os模块 import shutil,os #复制单个文件 shutil.copy(&amp;#34;C:\\a\\1.txt&amp;#34;,&amp;#34;C:\\b&amp;#34;) #复制并重命名新文件 shutil.copy(&amp;#34;C:\\a\\2.txt&amp;#34;,&amp;#34;C:\\b\\121.txt&amp;#34;) #复制整个目录(备份) shutil.copytree(&amp;#34;C:\\a&amp;#34;,&amp;#34;C:\\b\\new_a&amp;#34;) #删除文件 os.unlink(&amp;#34;C:\\b\\1.txt&amp;#34;) #或os.remove() os.unlink(&amp;#34;C:\\b\\121.txt&amp;#34;) #删除空文件夹 try: os.rmdir(&amp;#34;C:\\b\\new_a&amp;#34;) except Exception as ex: print(&amp;#34;错误信息：&amp;#34;+str(ex))#提示：错误信息，目录不是空的 #删除文件夹及内容 shutil.rmtree(&amp;#34;C:\\b\\new_a&amp;#34;) #移动文件 shutil.move(&amp;#34;C:\\a\\1.txt&amp;#34;,&amp;#34;C:\\b&amp;#34;) #移动文件夹 shutil.move(&amp;#34;C:\\a\\c&amp;#34;,&amp;#34;C:\\b&amp;#34;) #重命名文件 shutil.move(&amp;#34;C:\\a\\2.txt&amp;#34;,&amp;#34;C:\\a\\new2.txt&amp;#34;) #重命名文件夹 shutil.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.5-random%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.5-random%E6%A8%A1%E5%9D%97/</guid><description> 【说明：未同步word文档】 程序中有很多地方需要用到随机字符，比如登录网站的随机验证码，通过random模块可以很容易生成随机字符串
&amp;gt;&amp;gt;&amp;gt; random.randrange(1,10) #返回1-10之间的一个随机数，不包括10 &amp;gt;&amp;gt;&amp;gt; random.randint(1,10) #返回1-10之间的一个随机数，包括10 &amp;gt;&amp;gt;&amp;gt; random.randrange(0, 100, 2) #随机选取0到100间的偶数 &amp;gt;&amp;gt;&amp;gt; random.random() #返回一个随机浮点数 &amp;gt;&amp;gt;&amp;gt; random.choice(&amp;#39;abce3#$@1&amp;#39;) #返回一个给定数据集合中的随机字符 &amp;#39;#&amp;#39; &amp;gt;&amp;gt;&amp;gt; random.sample(&amp;#39;abcdefghij&amp;#39;,3) #从多个字符中选取特定数量的字符 [&amp;#39;a&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;b&amp;#39;] #生成随机字符串 &amp;gt;&amp;gt;&amp;gt; import string &amp;gt;&amp;gt;&amp;gt; &amp;#39;&amp;#39;.join(random.sample(string.ascii_lowercase + string.digits, 6)) &amp;#39;4fvda1&amp;#39; #洗牌 &amp;gt;&amp;gt;&amp;gt; a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &amp;gt;&amp;gt;&amp;gt; random.shuffle(a) &amp;gt;&amp;gt;&amp;gt; a [3, 0, 7, 2, 1, 6, 5, 8, 9, 4]</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.5-time%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.5-time%E6%A8%A1%E5%9D%97/</guid><description>sleep()方法 import time time.sleep(3) #代码执行暂停3s 字符串时间 t=time.ctime() #当前系统时间 print(t) # Fri Oct 20 12:24:28 2017 时间戳 t=time.time() #当前系统时间戳 print(t) # 1508473468.7305713 时间对象（时间元组） print(time.gmtime()) #返回一个struct_time时间对象，可以分别调用时间的各个组成部分.utc时间 # time.struct_time(tm_year=2017, tm_mon=10, tm_mday=20, tm_hour=4, tm_min=13, tm_sec=14, tm_wday=4, tm_yday=293, tm_isdst=0) r=time.gmtime() print(r.tm_year) # 2017 print(time.localtime()) #返回本地当前时间的struct_time对象（时间元组） #time.struct_time(tm_year=2021, tm_mon=8, tm_mday=7, tm_hour=21, tm_min=23, tm_sec=22, tm_wday=5, tm_yday=219, tm_isdst=0) 转换 时间元组生成时间戳 t1 = (2020, 9, 23, 16, 0, 0, 0, 0, 0) t=time.mktime(t1) #生成时间戳 # 1600848000.0 t2=time.localtime() #时间元组 print(time.mktime(t2)) #时间对象struct_time转换为时间戳 # 1508483326.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.6-re%E6%A8%A1%E5%9D%97-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.6-re%E6%A8%A1%E5%9D%97-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>python中正则表达式的实现内置模块re模块来实现。
正则表达式基础 元字符 .（点）：匹配****任意********单个****字符(除换行符\n以外)
[]（中括号）：匹配指定范围内的****任意********单个****字符（字符集合）
[^]（中括号中有个“^”）：匹配指定范围外的****任意********单个****字符
如果[]中有正则的元字符时，这些字符会失去特殊意义，被视作普通字符。但“-”、“^”、“\”除外，他们仍然有特殊意义。
\ (转移字符)：
转义：使后面的字符脱去原先的特殊含义，如：* 后面跟特殊字符实现特殊功能，如 \d：任何一个数字字符，等同于[0-9] \D：任何一个非数字字符，等同于[^0-9] \s：匹配任何不可见字符，相当于[\t\n\r\f\v] \S：匹配任何可见字符，相当于[^\t\n\r\f\v] \w：匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]” \W：匹配任何非单词字符。等价于“[^A-Za-z0-9_]” \b：锚定词首， 分组的后向引用 ：\1，\2 匹配次数 匹配次数 *：匹配其前面的字符任意次。【例如】 .* :任意长度的任意字符
?：匹配其前面的字符1次或0次（表示有或没有）
+：≥1次（至少1次）
{m,n}：匹配其前面的字符至少m次，至多n次。【例如】{1,} {0,3}
贪婪模式 默认情况下，以上四种*、？、+、{m,n}采用的是贪婪模式。如果要启用非贪婪模式，在匹配次数的元字符后加“？”，它表示成功匹配次数的最少次数。如\d*?
*?表示0次；
??表示0次；
+?表示1次；
{m,n}?表示m次。
说明：在分析匹配模板时，请无视“？”的存在。
什么是贪婪模式？什么是非贪婪模式？ 举个例子，贪婪模式解析：
源字符串：aa&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;bb&amp;lt;div&amp;gt;test2&amp;lt;/div&amp;gt;cc 正则表达式：&amp;lt;div&amp;gt;.*&amp;lt;/div&amp;gt; 非贪婪模式下，在匹配到第一个“&amp;lt;/div&amp;gt;”时已经可以使整个表达式匹配成功，结束匹配，匹配结果为“&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;”。但是由于采用的是贪婪模式，所以仍然要向右尝试匹配，查看是否还有更长的可以成功匹配的子串，匹配到第二个“&amp;lt;/div&amp;gt;”后，向右再没有可以成功匹配的子串，匹配结束，匹配结果为“&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;bb&amp;lt;div&amp;gt;test2&amp;lt;/div&amp;gt;”。
贪婪模式匹配的是第一个&amp;lt;div&amp;gt;和最后一个&amp;lt;/div&amp;gt;，非贪婪模式匹配的是第一个&amp;lt;div&amp;gt;和第一个&amp;lt;/div&amp;gt;。
位置锚定（定位元字符） ^：锚定行首，此字符后面的任意内容必须出现在行首
$：锚定行尾，此字符前面的任意内容必须出现在行尾
^$：空白行
\b：锚定单词边界
\b：锚定词首，其后面的任意字符必须作为单词首部出现 \b：锚定词尾，其前面的任意字符必须作为单词的尾部出现 单词：以字母组成，空格或标点符号隔开的字符串，不能有标点、数字等
|：或。例如(a|b)*，表示任意多个a或任意多个b
( )：分组
作用1：(ab)* ，表示ab作为一个整体被星号*修饰 作用2：后向引用，被括号括起来的内容后面可以用某个字符再次引用它 \1: 引用第一个左括号以及与之对应的右括号所包括的所有内容 \2: \3: re模块方法 re.match(pattern, string, flags=0) 从首字母开始开始匹配，string如果包含pattern子串，则匹配成功，返回Match对象，失败则返回None。也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none。
flags可以设置的值:
re.I （ignorecase）匹配时，不区分大小写 re.M （multiline）可以同时在多行中匹配 re.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.7-pickle-json-shelve%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.7-pickle-json-shelve%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97/</guid><description>【说明：未同步word文档】 什么叫序列化？ 序列化是指把内存里的数据类型转变成字符串，以使其能存储到硬盘或通过网络传输到远程，因为硬盘或网络传输时只能接受bytes
为什么要序列化？ 你打游戏过程中，打累了，停下来，关掉游戏、想过2天再玩，2天之后，游戏又从你上次停止的地方继续运行，你上次游戏的进度肯定保存在硬盘上了，是以何种形式呢？游戏过程中产生的很多临时数据是不规律的，可能在你关掉游戏时正好有10个列表，3个嵌套字典的数据集合在内存里，需要存下来？你如何存？把列表变成文件里的多行多列形式？那嵌套字典呢？根本没法存。所以，若是有种办法可以直接把内存数据存到硬盘上，下次程序再启动，再从硬盘上读回来，还是原来的格式的话，那是极好的。
用于序列化的两个模块
json，用于字符串 和 python数据类型间进行转换 pickle，用于python特有的类型 和 python的数据类型间进行转换 pickle模块提供了四个功能：dumps、dump、loads、load
import pickle data = {&amp;#39;k1&amp;#39;:123,&amp;#39;k2&amp;#39;:&amp;#39;Hello&amp;#39;} # pickle.dumps 将数据通过特殊的形式转换位只有python语言认识的字符串 p_str = pickle.dumps(data) # 注意dumps会把数据变成bytes格式 print(p_str) # pickle.dump 将数据通过特殊的形式转换位只有python语言认识的字符串，并写入文件 with open(&amp;#39;result.pk&amp;#39;,&amp;#34;wb&amp;#34;) as fp: pickle.dump(data,fp) # pickle.load 从文件里加载 f = open(&amp;#34;result.pk&amp;#34;,&amp;#34;rb&amp;#34;) d = pickle.load(f) print(d) Json模块也提供了四个功能：dumps、dump、loads、load，用法跟pickle一致
import json # json.dumps 将数据通过特殊的形式转换位所有程序语言都认识的字符串 j_str = json.dumps(data) # 注意json dumps生成的是字符串，不是bytes print(j_str) #dump入文件 with open(&amp;#39;result.json&amp;#39;,&amp;#39;w&amp;#39;) as fp: json.dump(data,fp) #从文件里load with open(&amp;#34;result.json&amp;#34;) as f: d = json.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.8-hashlib/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.8-hashlib/</guid><description> 【说明：未同步word文档】 import hashlib # md5 m = hashlib.md5() m.update(b&amp;#34;Hello&amp;#34;) m.update(b&amp;#34;It&amp;#39;s me&amp;#34;) print(m.digest()) # 返回2进制格式的hash值 m.update(b&amp;#34;It&amp;#39;s been a long time since last time we ...&amp;#34;) print(m.hexdigest()) # 返回16进制格式的hash值 # sha1 s1 = hashlib.sha1() s1.update(&amp;#34;小猿圈&amp;#34;.encode(&amp;#34;utf-8&amp;#34;)) s1.hexdigest() # sha256 s256 = hashlib.sha256() s256.update(&amp;#34;小猿圈&amp;#34;.encode(&amp;#34;utf-8&amp;#34;)) s256.hexdigest() # sha512 s512 = hashlib.sha256() s512.update(&amp;#34;小猿圈&amp;#34;.encode(&amp;#34;utf-8&amp;#34;)) s512.hexdigest()</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.9-urllib.request-http%E8%AF%B7%E6%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/20.9-urllib.request-http%E8%AF%B7%E6%B1%82/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/20-%E6%A8%A1%E5%9D%97/%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid><description> os.system(cmd) os.system(cmd)的返回值。如果执行成功，那么会返回0，表示命令执行成功。否则，则是执行错误。
os.popen() 通过 os.popen() 返回的是 file read 的对象，对其进行读取 read() 的操作可以看到执行的输出。
这种调用方式是通过管道的方式来实现，函数返回一个file-like的对象，里面的内容是脚本输出的内容（可简单理解为echo输出的内容）。
output = os.popen(&amp;#39;cat /proc/cpuinfo&amp;#39;) print output.read() commands.getstatusoutput() 读取程序执行的返回值和输出
import commands (status, output) = commands.getstatusoutput(&amp;#39;cat /proc/cpuinfo&amp;#39;) print status, output # (0, &amp;#39;aaaaaaa&amp;#39;) psutil.popen() subprocess.popen()</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/21-Python3%E6%93%8D%E4%BD%9CMySQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/21-Python3%E6%93%8D%E4%BD%9CMySQL/</guid><description>Python3 MySQL 数据库连接 - PyMySQL 驱动 本文我们为大家介绍 Python3 使用 PyMySQL 连接数据库，并实现简单的增删改查。
什么是 PyMySQL？ PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。
PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。
PyMySQL 安装 在使用 PyMySQL 之前，我们需要确保 PyMySQL 已安装。
PyMySQL 下载地址：https://github.com/PyMySQL/PyMySQL。
pip安装 如果还未安装，我们可以使用以下命令安装最新版的 PyMySQL：
$ pip3 install PyMySQL 源码安装 如果你的系统不支持 pip 命令，可以使用以下方式安装：
1、使用 git 命令下载安装包安装(你也可以手动下载)：
$ git clone https://github.com/PyMySQL/PyMySQL $ cd PyMySQL/ $ python3 setup.py install 2、如果需要制定版本号，可以使用 curl 命令来安装：
$ # X.X 为 PyMySQL 的版本号 $ curl -L https://github.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/22-pymongo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/22-pymongo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>#!/usr/bin/env python # -*- coding:utf-8 -*- &amp;#34;&amp;#34;&amp;#34; MongoDB存储 在这里我们来看一下Python3下MongoDB的存储操作，在本节开始之前请确保你已经安装好了MongoDB并启动了其服务，另外安装好了Python 的PyMongo库。 连接MongoDB 连接MongoDB我们需要使用PyMongo库里面的MongoClient，一般来说传入MongoDB的IP及端口即可，第一个参数为地址host， 第二个参数为端口port，端口如果不传默认是27017。 &amp;#34;&amp;#34;&amp;#34; import pymongo client = pymongo.MongoClient(host=&amp;#39;localhost&amp;#39;, port=27017) &amp;#34;&amp;#34;&amp;#34; 这样我们就可以创建一个MongoDB的连接对象了。另外MongoClient的第一个参数host还可以直接传MongoDB的连接字符串，以mongodb开头， 例如：client = MongoClient(&amp;#39;mongodb://localhost:27017/&amp;#39;)可以达到同样的连接效果。 &amp;#34;&amp;#34;&amp;#34; # 指定数据库 # MongoDB中还分为一个个数据库，我们接下来的一步就是指定要操作哪个数据库，在这里我以test数据库为例进行说明，所以下一步我们 # 需要在程序中指定要使用的数据库。 db = client.test # 调用client的test属性即可返回test数据库，当然也可以这样来指定： # db = client[&amp;#39;test&amp;#39;] #　两种方式是等价的。 # 指定集合 # MongoDB的每个数据库又包含了许多集合Collection，也就类似与关系型数据库中的表，下一步我们需要指定要操作的集合， # 在这里我们指定一个集合名称为students，学生集合。还是和指定数据库类似，指定集合也有两种方式。 collection = db.students # collection = db[&amp;#39;students&amp;#39;] # 插入数据,接下来我们便可以进行数据插入了，对于students这个Collection，我们新建一条学生数据，以字典的形式表示： student = { &amp;#39;id&amp;#39;: &amp;#39;20170101&amp;#39;, &amp;#39;name&amp;#39;: &amp;#39;Jordan&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;gender&amp;#39;: &amp;#39;male&amp;#39; } # 在这里我们指定了学生的学号、姓名、年龄和性别，然后接下来直接调用collection的insert()方法即可插入数据。 result = collection.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/7.1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/7.1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Python中格式换字符串一般使用有2种方法。
一、使用%格式化表达式格式化字符串 格式化后的字符串可以使用print()打印。
&amp;gt;&amp;gt;&amp;gt; &amp;#39;That is %d %s bird!&amp;#39; % (1, &amp;#39;dead&amp;#39;) &amp;#39;That is 1 dead bird!&amp;#39; &amp;gt;&amp;gt;&amp;gt; print(&amp;#39;That is %d %s bird!&amp;#39; % (1, &amp;#39;dead&amp;#39;)) That is 1 dead bird! 格式：“含%typecode的字符串模板” % 元组或字典 在%操作符右侧放置一个对象（或多个对象，嵌入到元组或字典中），这些对象将会插入到左侧想让Python进行格式化字符串的一个（或多个）转换目标的位置上去。
字符码typecode 在%操作符的左侧放置一个需要进行格式化的字符串，这个字符串带有一个或多个嵌入的转换目标(%typecode)，都以%开头（例如，%d）。
字符码（typecode） 描述 s 字符串 (或任何字符串对象) ,使用__str__ 的返回值 r 类似s, 但使用 repr, 而不是__str__ 的返回值 c 字符，unicode整数对应的character d 十进制 (整数) i 整数 u 与 d 一样(废弃: 不再使用) o 八进制整数 （将10进制对应的数转换为八进制） x 十六进制整数 X 与x一样, 但打印大写 e 浮点指数，即科学记数法 E 与 e 一样, 但打印大写 f 浮点十进制 ，默认6位小数 F 浮点十进制，同f g 自动选择浮点 e 或 f ，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学记数则是e；） G 浮点 E 或 F % 常量 % 修饰符格式说明 在%和typecode之间，可以使用修饰符：%[(key_name)][flags][width][.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/pip%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E6%BA%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/pip%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E6%BA%90/</guid><description>pip 安装完成后会在家目录创建一个目录.pip
linux操作系统下 mkdir ~/.pip vi ~/.pip/pip.conf [global] trusted-host = mirrors.aliyun.com index-url = https://mirrors.aliyun.com/pypi/simple 然后写入如下内容并保存
可以直接使用如下脚本生成：
[ -d &amp;#34;~/.pip&amp;#34; ] || mkdir ~/.pip cat &amp;gt;~/.pip/pip.conf &amp;lt;&amp;lt;EOF [global] trusted-host = mirrors.aliyun.com index-url = https://mirrors.aliyun.com/pypi/simple EOF windows操作系统下 位置： %HOMEPATH%\pip\pip.ini
[global] trusted-host = mirrors.aliyun.com index-url = https://mirrors.aliyun.com/pypi/simple 临时指定源 也可以在使用pip命令时临时指定仓库地址：
pip install -i https://mirrors.aliyun.com/pypi/simple psutil</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/python%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/python%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9/</guid><description>help() 第1步：调用内置的dir(obj)函数，将会返回一个列表，其中包含了对象的所有属性。由于方法是函数属性，它们也会在这个列表中出现。
假设S是一个字符串，dir(S)；如果不是某个特定的字符串变量，可以使用dir(str) 查看字符串这个对象的属性。
&amp;gt;&amp;gt;&amp;gt; s=&amp;#39;str&amp;#39; &amp;gt;&amp;gt;&amp;gt; dir(s) [&amp;#39;__add__&amp;#39;, &amp;#39;__class__&amp;#39;, &amp;#39;__contains__&amp;#39;, &amp;#39;__delattr__&amp;#39;, &amp;#39;__dir__&amp;#39;, &amp;#39;__doc__&amp;#39;, &amp;#39;__eq__&amp;#39;, &amp;#39;__format__&amp;#39;, &amp;#39;__ge__&amp;#39;, &amp;#39;__getattribute__&amp;#39;, &amp;#39;__getitem__&amp;#39;, &amp;#39;__getnewargs__&amp;#39;, &amp;#39;__gt__&amp;#39;, &amp;#39;__hash__&amp;#39;, &amp;#39;__init__&amp;#39;, &amp;#39;__init_subclass__&amp;#39;, &amp;#39;__iter__&amp;#39;, &amp;#39;__le__&amp;#39;, &amp;#39;__len__&amp;#39;, &amp;#39;__lt__&amp;#39;, &amp;#39;__mod__&amp;#39;, &amp;#39;__mul__&amp;#39;, &amp;#39;__ne__&amp;#39;, &amp;#39;__new__&amp;#39;, &amp;#39;__reduce__&amp;#39;, &amp;#39;__reduce_ex__&amp;#39;, &amp;#39;__repr__&amp;#39;, &amp;#39;__rmod__&amp;#39;, &amp;#39;__rmul__&amp;#39;, &amp;#39;__setattr__&amp;#39;, &amp;#39;__sizeof__&amp;#39;, &amp;#39;__str__&amp;#39;, &amp;#39;__subclasshook__&amp;#39;, &amp;#39;capitalize&amp;#39;, &amp;#39;casefold&amp;#39;, &amp;#39;center&amp;#39;, &amp;#39;count&amp;#39;, &amp;#39;encode&amp;#39;, &amp;#39;endswith&amp;#39;, &amp;#39;expandtabs&amp;#39;, &amp;#39;find&amp;#39;, &amp;#39;format&amp;#39;, &amp;#39;format_map&amp;#39;, &amp;#39;index&amp;#39;, &amp;#39;isalnum&amp;#39;, &amp;#39;isalpha&amp;#39;, &amp;#39;isascii&amp;#39;, &amp;#39;isdecimal&amp;#39;, &amp;#39;isdigit&amp;#39;, &amp;#39;isidentifier&amp;#39;, &amp;#39;islower&amp;#39;, &amp;#39;isnumeric&amp;#39;, &amp;#39;isprintable&amp;#39;, &amp;#39;isspace&amp;#39;, &amp;#39;istitle&amp;#39;, &amp;#39;isupper&amp;#39;, &amp;#39;join&amp;#39;, &amp;#39;ljust&amp;#39;, &amp;#39;lower&amp;#39;, &amp;#39;lstrip&amp;#39;, &amp;#39;maketrans&amp;#39;, &amp;#39;partition&amp;#39;, &amp;#39;replace&amp;#39;, &amp;#39;rfind&amp;#39;, &amp;#39;rindex&amp;#39;, &amp;#39;rjust&amp;#39;, &amp;#39;rpartition&amp;#39;, &amp;#39;rsplit&amp;#39;, &amp;#39;rstrip&amp;#39;, &amp;#39;split&amp;#39;, &amp;#39;splitlines&amp;#39;, &amp;#39;startswith&amp;#39;, &amp;#39;strip&amp;#39;, &amp;#39;swapcase&amp;#39;, &amp;#39;title&amp;#39;, &amp;#39;translate&amp;#39;, &amp;#39;upper&amp;#39;, &amp;#39;zfill&amp;#39;] &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; dir(str) [&amp;#39;__add__&amp;#39;, &amp;#39;__class__&amp;#39;, &amp;#39;__contains__&amp;#39;, &amp;#39;__delattr__&amp;#39;, &amp;#39;__dir__&amp;#39;, &amp;#39;__doc__&amp;#39;, &amp;#39;__eq__&amp;#39;, &amp;#39;__format__&amp;#39;, &amp;#39;__ge__&amp;#39;, &amp;#39;__getattribute__&amp;#39;, &amp;#39;__getitem__&amp;#39;, &amp;#39;__getnewargs__&amp;#39;, &amp;#39;__gt__&amp;#39;, &amp;#39;__hash__&amp;#39;, &amp;#39;__init__&amp;#39;, &amp;#39;__init_subclass__&amp;#39;, &amp;#39;__iter__&amp;#39;, &amp;#39;__le__&amp;#39;, &amp;#39;__len__&amp;#39;, &amp;#39;__lt__&amp;#39;, &amp;#39;__mod__&amp;#39;, &amp;#39;__mul__&amp;#39;, &amp;#39;__ne__&amp;#39;, &amp;#39;__new__&amp;#39;, &amp;#39;__reduce__&amp;#39;, &amp;#39;__reduce_ex__&amp;#39;, &amp;#39;__repr__&amp;#39;, &amp;#39;__rmod__&amp;#39;, &amp;#39;__rmul__&amp;#39;, &amp;#39;__setattr__&amp;#39;, &amp;#39;__sizeof__&amp;#39;, &amp;#39;__str__&amp;#39;, &amp;#39;__subclasshook__&amp;#39;, &amp;#39;capitalize&amp;#39;, &amp;#39;casefold&amp;#39;, &amp;#39;center&amp;#39;, &amp;#39;count&amp;#39;, &amp;#39;encode&amp;#39;, &amp;#39;endswith&amp;#39;, &amp;#39;expandtabs&amp;#39;, &amp;#39;find&amp;#39;, &amp;#39;format&amp;#39;, &amp;#39;format_map&amp;#39;, &amp;#39;index&amp;#39;, &amp;#39;isalnum&amp;#39;, &amp;#39;isalpha&amp;#39;, &amp;#39;isascii&amp;#39;, &amp;#39;isdecimal&amp;#39;, &amp;#39;isdigit&amp;#39;, &amp;#39;isidentifier&amp;#39;, &amp;#39;islower&amp;#39;, &amp;#39;isnumeric&amp;#39;, &amp;#39;isprintable&amp;#39;, &amp;#39;isspace&amp;#39;, &amp;#39;istitle&amp;#39;, &amp;#39;isupper&amp;#39;, &amp;#39;join&amp;#39;, &amp;#39;ljust&amp;#39;, &amp;#39;lower&amp;#39;, &amp;#39;lstrip&amp;#39;, &amp;#39;maketrans&amp;#39;, &amp;#39;partition&amp;#39;, &amp;#39;replace&amp;#39;, &amp;#39;rfind&amp;#39;, &amp;#39;rindex&amp;#39;, &amp;#39;rjust&amp;#39;, &amp;#39;rpartition&amp;#39;, &amp;#39;rsplit&amp;#39;, &amp;#39;rstrip&amp;#39;, &amp;#39;split&amp;#39;, &amp;#39;splitlines&amp;#39;, &amp;#39;startswith&amp;#39;, &amp;#39;strip&amp;#39;, &amp;#39;swapcase&amp;#39;, &amp;#39;title&amp;#39;, &amp;#39;translate&amp;#39;, &amp;#39;upper&amp;#39;, &amp;#39;zfill&amp;#39;] &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; dir(list) [&amp;#39;__add__&amp;#39;, &amp;#39;__class__&amp;#39;, &amp;#39;__contains__&amp;#39;, &amp;#39;__delattr__&amp;#39;, &amp;#39;__delitem__&amp;#39;, &amp;#39;__dir__&amp;#39;, &amp;#39;__doc__&amp;#39;, &amp;#39;__eq__&amp;#39;, &amp;#39;__format__&amp;#39;, &amp;#39;__ge__&amp;#39;, &amp;#39;__getattribute__&amp;#39;, &amp;#39;__getitem__&amp;#39;, &amp;#39;__gt__&amp;#39;, &amp;#39;__hash__&amp;#39;, &amp;#39;__iadd__&amp;#39;, &amp;#39;__imul__&amp;#39;, &amp;#39;__init__&amp;#39;, &amp;#39;__init_subclass__&amp;#39;, &amp;#39;__iter__&amp;#39;, &amp;#39;__le__&amp;#39;, &amp;#39;__len__&amp;#39;, &amp;#39;__lt__&amp;#39;, &amp;#39;__mul__&amp;#39;, &amp;#39;__ne__&amp;#39;, &amp;#39;__new__&amp;#39;, &amp;#39;__reduce__&amp;#39;, &amp;#39;__reduce_ex__&amp;#39;, &amp;#39;__repr__&amp;#39;, &amp;#39;__reversed__&amp;#39;, &amp;#39;__rmul__&amp;#39;, &amp;#39;__setattr__&amp;#39;, &amp;#39;__setitem__&amp;#39;, &amp;#39;__sizeof__&amp;#39;, &amp;#39;__str__&amp;#39;, &amp;#39;__subclasshook__&amp;#39;, &amp;#39;append&amp;#39;, &amp;#39;clear&amp;#39;, &amp;#39;copy&amp;#39;, &amp;#39;count&amp;#39;, &amp;#39;extend&amp;#39;, &amp;#39;index&amp;#39;, &amp;#39;insert&amp;#39;, &amp;#39;pop&amp;#39;, &amp;#39;remove&amp;#39;, &amp;#39;reverse&amp;#39;, &amp;#39;sort&amp;#39;] 第2步：调用help()获取具体帮助，函数help(str.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/python%E7%9A%84%E7%9C%9F%E4%B8%8E%E5%81%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/python%E7%9A%84%E7%9C%9F%E4%B8%8E%E5%81%87/</guid><description>真和假是每个对象的固有属性，每个对象要么为真要么为假：
数字非零为真；其他对象非空为真。（None对象为假，即False包含：零、空对象、None对象） bool类型只是扩展了真与假的概念，bool值为True（1）和False（0），注意首字母大写，他们只不过是整数1和整数0的定制版本而已。 例如：
prinf(True==2) #False prinf(True==1) #True</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid><description>python3的虚拟环境 1、python3的虚拟环境介绍 Python 虚拟环境 pyenv、venv(pyvenv)、virtualenv之间的区别
Python3.3以上的版本通过venv模块原生支持虚拟环境，可以代替Python之前的virtualenv。
该venv模块提供了创建轻量级“虚拟环境”，提供与系统Python的隔离支持。每一个虚拟环境都有其自己的Python二进制（允许有不同的Python版本创作环境），并且可以拥有自己独立的一套Python包。他最大的好处是，可以让每一个python项目单独使用一个环境，而不会影响python系统环境，也不会影响其他项目的环境。
2、linux创建虚拟环境 其实linux mac win三个平台的方法没什么太大区别，这里通过Linux系统演示，python环境依然是python3.5
创建 py3 虚拟环境(-m表示将模块作为脚本运行) # python3.6 -m venv -h 查看模块venv的帮助 $ python3 -m venv /opt/py3 载入 py3 虚拟环境 # 每次操作都需要使用下面的命令载入 py3 虚拟环境 $ source /opt/py3/bin/activate # 偷懒可以在 ~/.bashrc 末尾加入 source /opt/py3/bin/activate # 关闭虚拟环境 $ deactivate 如下图：
这样虚拟环境就创建完成
1.2 windows创建虚拟环境 安装好的python3的环境，我的python版本是python3.5
我这里演示例子是在c盘根目录建立一个py3目录
#创建虚拟环境 python -m evnv C:/py3 以上命令表示在当前目录将even模块以脚本的形式进行运行。
命令执行完成会在py3目录下看到如下文件
激活虚拟环境 还是在windows cmd下操作： 进入到Scripts,执行activate.bat，如下图表示激活成功
这个时候可以在虚拟环境进入到python3并安装我们需要的包而不会影响我们系统安装的python3的包环境，这里我在虚拟环境中安装了pymysql包，然后分别在虚拟环境和外面的环境中pip list列出包，可以看到，我们外面的包中并没有pymysql包
这样一个虚拟环境我们就配置好了</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Python/</guid><description>编译安装很简单：
$ wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xz $ tar xvf Python-3.6.1.tar.xz &amp;amp;&amp;amp; cd Python-3.6.1 $ ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E6%8E%A8%E8%8D%90%E5%8D%9A%E5%AE%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E6%8E%A8%E8%8D%90%E5%8D%9A%E5%AE%A2/</guid><description>https://book.apeland.cn/details/67/</description></item></channel></rss>