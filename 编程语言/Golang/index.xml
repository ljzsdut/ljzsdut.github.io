<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on ljzsdut</title><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/</link><description>Recent content in Golang on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/00-%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/00-%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</guid><description>在 Golang 中使用 Cobra 创建 CLI 应用
李文周golang：https://www.liwenzhou.com/posts/Go/golang-menu/
type语法 https://www.cnblogs.com/smartrui/p/11425822.html
https://studygolang.com/articles/17179
https://www.jianshu.com/p/6ca70382bb42
type使用背景 对一个新的类型进行定义，我们称之为“类型声明”。对于某个类型声明可以直接使用，也可以使用type关键字对这个“类型声明”进行命名操作。
比如我们有一个类型声明，定义如下：
struct { name string age int } 下面直接对该类型进行实例化对象：
func b() { s := struct { name string age int }{&amp;#34;ljz&amp;#34;, 15} fmt.Printf(&amp;#34;%#v&amp;#34;,s) } 而我们常用的方式，是先对类型声明进行命名：
type persion struct { name string age int } func c() { s := persion{&amp;#34;ljz&amp;#34;, 15} fmt.Printf(&amp;#34;%#v&amp;#34;,s) } type概述 type关键字的作用：为“类型声明”命名。通过type关键字，可以对各种类型进行命名，使之成为“命名类型(defined type)”
语法：type T 类型声明：此后，T为“类型声明”的名字，可以直接使用T来引用该类型。
golang中的各种数据类型：
int 、int32、int64、floating32、string、bool //GO中预先声明类型 数组，切片，map，通道，指针，结构体，接口，函数 // 组合类型 struct{.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/01-1_Golang%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/01-1_Golang%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC/</guid><description>Golang中的变量相关总结 变量声明与赋值的几种方式 1、先声明，再赋值
var VAR TYPE VAR = 类型实例 2、声明并赋值
var VAR TYPE = 类型实例 3、类型推导
var VAR = 类型实例 4、短变量声明（只能在函数内部使用）
VAR := 类型实例 示例：
基本数据类型 复合数据类型 备注 var num int
num = 5 var s []int
s = []int{1,2,3} 对于符合数据类型，例如slice，TYPE为&amp;quot;[]int&amp;quot; var num int = 5 var s []int = []int{1,2,3} var num = 5 var s = []int{1,2,3} num := 5 s := []int{1,2,3} 关于类型实例的说明： 1、对于基本数据类型，其类型实例就是字面量，如5是int类型的一个实例，&amp;ldquo;hello&amp;quot;是string类型的一个实例；
2、对于复合数据类型，其类型实例需要使用new()/make()进行实例化，也可以通过TYPE{}的方式进行类型TYPE的实例化。
3、实例化本质：根据类型TYPE分配固定大小的内存空间（类型是有大小的）。需要说明的是var VAR TYPE语句对于指针类型的VAR是没有分配内存空间的，此时其值为nil，例如slice、map、channel。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/01_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/01_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</guid><description>[TOC]
变量 1 变量的本质 1.1内存的介绍 ​ 内存是一块存储空间，而且它具有地址编号（可被寻址）。寻址空间一般指的是CPU对于内存寻址的能力，通俗地说，就是能CPU最多用到多少内存的一个问题。数据在存储器(RAM)中存放是有规律的 ，CPU在运算的时候需要把数据提取出来就需要知道数据存放在哪里，这时候就需要挨家挨户的找，这就叫做寻址，但如果地址太多超出了CPU的能力范围，CPU就无法找到数据了。CPU最大能查找多大范围的地址叫做寻址能力 ，CPU的寻址能力以字节为单位 ，如32位寻址的CPU(32位操作系统)可以寻址2的32次方大小的地址也就是4G，这也是为什么32位的操作系统CPU最大能搭配4G内存的原因 ，再多的话CPU就找不到了。
1.2 变量的本质 ​ 变量本质上就是代表一个”被命名的、可操作的内存空间”，空间的位置是确定的，但是里面放置什么值不确定。该空间有自己的名称(变量名)和类型(变量类型)。我们可通过变量名来访问“对应的内存空间”，从而操纵这个“内存空间”存储的值。
​ 变量和内存之间的关系：
对于编译型的语言，通过变量声明来申请(变量类型决定了申请多大的固定大小的连续空间)和命名内存空间(变量名称决定了内存空间的别名）。如golang中的：var a int
通过变量名(内存地址的别名)访问内存空间。变量名就是（一段连续）内存空间的别名（是一个门牌号）
变量的值(内存空间存储的值)可以直接或间接地修改
直接：通过变量名进行修改。如：a=10
间接：内存有地址编号，拿到地址编号也可以修改内存(如指针，一个特殊的变量(内存空间)，存储的其他的内存空间的地址)，如golang中。ptr=&amp;amp;a;*ptr=10
2 Golang变量的定义、赋值 2.1 变量声明： var关键字开头，变量名后指定变量类型。声明后不赋值，则使用默认零值。
var num int // 变量声明后，后自动赋值一个默认零值，不同类型的默认零值是不同的： // 1、对int类型的变量会默认初始化为0； // 2、对string类型的变量会初始化为空&amp;#34;&amp;#34;； // 3、对布尔类型的变量会初始化为false； // 4、对指针(引用)类型的变量(slice、指针、map、channel、函数)会初始化为nil，等等。 // 5、对于像数组或结构体这样的复合类型，零值是其所有元素或成员的零值。 批量声明：Golang支持一次性声明多个变量
var n1, n2, n3 int Go中有4个主要的声明：变量（var）、常量（const）、类型（type）、函数（func）
2.2 变量赋值： 对已声明的变量进行赋值：
var num int num = 10 变量声明时，同时对其赋值：
var num int = 20 初始值设定可以是字面量值或者任意表达式。例如var f , err = os.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/02_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/02_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>[TOC]
基本数据类型 ​ 虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。进一步将这些数组织在一起，就可表达更多的对象，例如数据包、像素点、诗歌，甚至其他任何对象。Go语言提供了丰富的数据组织形式，这依赖于Go语言内置的数据类型。这些内置的数据类型，兼顾了硬件的特性和表达复杂数据结构的便捷性。
​ Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。基础类型，包括：数字、字符串和布尔型。复合数据类型：数组和结构体，是通过组合简单类型，来表达更加复杂的数据结构。引用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。(Go语言的数值类型包括整形数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。)
1 整形 1.2 整形分类 ​ Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整形数类型，分别对应8、16、32、64bit大小的有符号整形数，与此对应的是uint8、uint16、uint32和uint64四种无符号整形数类型。
​ 还有两种依赖于CPU位数的类型：有符号和无符号整数int和uint，它们分别表示一个机器字长。在32位CPU上，一个机器字长为32bit，共4字节，在64位CPU上，一个机器字长为64bit，共8字节。
除了int和uint依赖于CPU架构，还有一种uintptr也是依赖于机器字长的。这种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程是才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。
有符号整形 无符号整形 特殊类型 int8 uint8 byte int16 uint16 int32 uint32 rune int64 uint64 int unit uintptr（了解） 1.2 整形兄弟类型间的类型转换 整形中，以上涉及到的的所有子类型，都是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小
func main() { var a int = 798 var b int32 // b = a //cannot use a (type int) as type int32 in assignment b = int32(a) fmt.Println(b) } 1.3 整形的不同进制表示 在整数加上0前缀表示这是8进制，例如077。加上前缀0x表示这是16进制，例如0x0c，使用e符号可以表示这是一个科学计数法，如1e3 = 1000,6.023e23 = 6.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/03_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/03_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>[TOC]
基本数据类型的类型转换 Go默认是不会进行数据类型的隐士转换的(即不能自动进行数据转换)，需要我们显示指定数据类型转换。
1 兄弟类型转换 类型转换的基本语法：TYPE(var)， TYPE表示数据类型，var表示要进行类型转换的变量。例如int32(a)
兄弟类型转换使用细节：
TYPE(var)这种方式只适合兄弟类型的转换(数字类型之间转换：int8 int32 float之间的转换)，不适合大类型之间转换（比如int32 与string之间的转换）。
不是所有数据类型都能转换的，例如字母格式的string类型&amp;quot;abcd&amp;quot;转换为int肯定会失败
被转换的是变量存储的数据(即值)，变量本身的数据类型没有发生变化。
在(范围)大转小的转换中，比如将int64转换为int8，编译时不会报错，只是转换的结果是按照溢出处理，和我们希望的结果不一样。
低精度转换为高精度时是安全的，高精度的值转换为低精度时会丢失精度。例如float32转换为int
2 大类型转换－基本数据类型转string类型 **方式1：使用fmt.Sprintf(&amp;quot;%参数&amp;quot;，表达式)函数， 根据于格式说明符进行格式化并返回其结果字符串。 **
func main() { var num1 int = 99 var num2 float32 = 23.456 var b bool = true var char byte = &amp;#39;h&amp;#39; var str1, str2, str3, str4 string str1 = fmt.Sprintf(&amp;#34;%d&amp;#34;, num1) str2 = fmt.Sprintf(&amp;#34;%f&amp;#34;, num2) str3 = fmt.Sprintf(&amp;#34;%t&amp;#34;, b) str4 = fmt.Sprintf(&amp;#34;%c&amp;#34;, char) fmt.Println(str1) // 99 fmt.Println(str2) // 23.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/04_%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/04_%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>[TOC]
运算符 1 算术运算符 算术运算符主要是对数值型变量进行运算。比如加减乘除等。golang的算术运算符中没有乘方的运算，可以使用math.Pow(m,n)计算m的n次方。
注意事项：
如果要使结果为浮点型，则除数和被除数至少有一个为浮点数。 (1) 5 / 2 =&amp;gt; 2 // 取整数部分，去掉小数部分，不是四舍五入。例如本例的2.5取值为2 (2) 5.0/2 =&amp;gt; 2.5 (3) 5/2.0=&amp;gt; 2.5 (4) 5.0/2.0=&amp;gt; 2.5 除号两边的变量类型要一致，否则需要进行转换，包括兄弟类型也要转换。(常量是无类型的) var n1 int8 = 25 var n2 int16 = 5 fmt.Println(n1 / n2) //invalid operation: n1 / n2 (mismatched types int8 and int16) Golang中取余的结果中的正负号与被除数一致。例如： (1) 10 % 3 =&amp;gt; 1 (2) 10 % -3 =&amp;gt; 1 (3) -10 % 3 =&amp;gt; -1 (4) -10 % -3 =&amp;gt; -1 Golang中，不存在++i和--i的运算，而且i++和i--只能独立使用，不能将其赋值给一个变量。例如a := i++和i++ &amp;gt; 0的形式是不正确的。 (1) i++等价于i = i + 1 (2) i--等价于i = i - 1 2 关系运算符 关系运算符主要有==、！=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt;= 。 关系运算符的结果都是bool型的，也就是要么是true，要么是false； 关系运算符组成的表达式我们称之为“关系表达式”。关系表达式经常用在if结构的条件中或循环结构的条件中。也可以用在复制语句中，例如flag := n1 &amp;lt; n2 3 逻辑运算符 逻辑运算符用来连接多个条件（一般为关系表达式），最终结果是一个bool型。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/05_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/05_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description>[TOC]
流程控制 三大流程控制语句：
(1) 顺序控制：程序从上到下逐行的执行，中间没有任何判断和跳转。
(2) 分支控制
(3) 循环控制
说明：控制语句可以使用相互嵌套。
1 分支控制 1.1 if-else分支控制语句 1.1.1 单分支控制 格式：
if condition { statements... } 说明：
(1) 大括号必须存在，哪怕逻辑块中只有1条语句；
(2) 大括号的左边部分{必须位于条件语句的后面，位于同一行；
(3) Golang中的条件表达式condition无需使用括号包围。当为了区分优先级时，可以使用括号；
(4) Golang中的if语句允许条件判断语句里面声明一个变量，这个变量的作用域是if语句的逻辑块中，在其他地方不起作用；变量声明语句与条件判断语句使用分号分隔。示例：if age := 20 ; age &amp;gt;18 {}
1.1.2 双分支控制 格式：
if condition { statements... } else { statements... } 说明：
(1) else关键字必须紧跟在}后面，不能单独一行；建议后面的{接在else关键字后面，位于同一行；
1.1.2 多分支控制 格式：
if condition { statements... } else if condition { statements... } else { statements... } 说明：</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/06_%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/06_%E5%87%BD%E6%95%B0/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</guid><description>Gin框架介绍及使用 [TOC]
Gin是一个用Go语言编写的web框架。它是一个类似于martini但拥有更好性能的API框架, 由于使用了httprouter，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上Gin。
Gin框架介绍 Go世界里最流行的Web框架，Github上有24K+star。 基于httprouter开发的Web框架。 中文文档齐全，简单易用的轻量级框架。
Gin框架安装与使用 安装 下载并安装Gin:
go get -u github.com/gin-gonic/gin 第一个Gin示例： package main import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func main() { // 创建一个默认的路由引擎 r := gin.Default() // GET：请求方式；/hello：请求的路径 // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数 r.GET(&amp;#34;/hello&amp;#34;, func(c *gin.Context) { // c.JSON：返回JSON格式的数据 c.JSON(200, gin.H{ &amp;#34;message&amp;#34;: &amp;#34;Hello world!&amp;#34;, }) }) // 启动HTTP服务，默认在0.0.0.0:8080启动服务 r.Run() } 将上面的代码保存并编译执行，然后使用浏览器打开127.0.0.1:8080/hello就能看到一串JSON字符串。
RESTful API REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。
推荐阅读阮一峰 理解RESTful架构
简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。
GET用来获取资源 POST用来新建资源 PUT用来更新资源 DELETE用来删除资源。 只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/go_template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/go_template/</guid><description>转载：https://www.liwenzhou.com/posts/Go/go_template/
概述 template本质上是字符串替换，是一种高级地字符串替换。
Go语言内置了文本模板引擎text/template和用于HTML文档的html/template。它们的作用机制可以简单归纳如下：
模板文件通常定义为.tmpl和.tpl为后缀（也可以使用其他的后缀），必须使用UTF8编码。 模板文件中使用{{和}}包裹和标识需要传入的数据。 传给模板这样的数据就可以通过点号（.）来访问，如果数据是复杂类型的数据，可以通过{ { .FieldName }}来访问它的字段。 除{{和}}包裹的内容外，其他内容均不做修改原样输出。 模板引擎的使用 Go语言模板引擎的使用可以分为三部分：定义模板文件、解析模板文件和模板渲染.
定义模板文件 其中，定义模板文件时需要我们按照相关语法规则去编写，后文（模板语法）会详细介绍。
解析模板文件 上面定义好了模板文件之后，可以使用下面的常用方法去解析模板文件，得到模板对象：
func (t *Template) Parse(src string) (*Template, error) func ParseFiles(filenames ...string) (*Template, error) func ParseGlob(pattern string) (*Template, error) 当然，你也可以使用func New(name string) *Template函数创建一个名为name的模板，然后对其调用上面的方法去解析模板字符串或模板文件。
模板渲染 渲染模板简单来说就是使用数据去填充模板，当然实际上可能会复杂很多。
func (t *Template) Execute(wr io.Writer, data interface{}) error func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error 基本示例 定义模板文件 我们按照Go模板语法定义一个hello.tmpl的模板文件，内容如下：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh-CN&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/GO%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/GO%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86/</guid><description>GOROOT与GOPATH是什么？ GOROOT环境变量用于指定golang开发包的安装位置，其中go的标准库位于$GOROOT/src目录下。
GOPATH环境变量指定workspace的位置，workspace就是写代码的位置。用来指示go从哪里搜索go源文件和第三方包。
从Go 1.8版本开始，Go开发包在安装完成后会为GOPATH设置一个默认目录（默认位置为$HOME/go(Unix)或%USERPROFILE%\go(Windows)）。 Go1.11版本之后官方推出的版本管理工具go module。启用go module后，代码无需必须写在$GOPATH/src中，可以使用Go module配置代码在任何位置 从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 到Go1.14版本推出之后Go modules 功能已经被正式推荐在生产环境下使用了，安装开发包后不需要做任何配置，默认配置就可以直接使用go module。 go需要导入包时，会依次从$GOROOT/src和$GOPATH/pkg所设置的位置处搜索标准库和第三方包。
workspace是什么？ 启用go module后，workspace基本就不具有存在的意义了。但是GOPATH还是有意义的，用于指定目录，存放第三方库文件或编译后可执行文件。
通过环境变量GOPATH设置workspace的路径。
由于可以将多个go项目放在同一个$GOPATH目录下，为了区分src下的不同的项目目录（或库文件目录），建议将每个项目目录设置为$GOPATH/src/{项目名称}/项目文件或目录。
每个workspace都是一个目录，这个目录下至少包含三个目录：
src：该目录用于存放项目源代码文件。使用go mod后，编写的go代码可以不放在该目录下。 bin：该目录用于存放可执行命令(即go install后可执行的二进制go程序，也称为命令文件) pkg：该目录用于存放共享库文件(即go get|mod后非可执行程序的库包，也称为包对象文件；go mod相关命令下载的库包位于pkg/mod/目录下) 依赖包是什么？ 每句代码都必须放在其中一个包中，使用package 包名声明当前文件属于哪个包。
一个包由位于单个目录下(不能跨多个目录)的一个或多个.go源代码文件组成。即一个包可以包含多个文件，但是这些文件都要放在同一个目录中。
目录名称一般与包名称一致，但是不用强制要求一致。
golang中包分为main包和库包(除了main包之外的包)。库包又分为标准包和第三方包。标准包位于$GOROOT/src目录下，第三方包下载后位于$GOPATH/pkg目录下。
go操作命令 go build：编译，编译后会在当前目录下生成一个可执行二进制文件：Windows下生成的是test.exe文件，Unix下生成的是test文件。编译时会对import导入的包进行搜索，搜索的路径为标准库所在路径$GOROOT/src、workspace下的src目录。它只会生成额外的可执行文件放在当前目录下，不会生成额外的库文件。
注意，生成的可执行文件名称可能会出乎意料：当go build以目录的形式进行编译，则生成的可执行文件名为目录名。当go build以go代码文件名的方式进行编译，则生成的可执行程序名为go源码文件名(去掉后缀.go或增加后缀.exe)。
go install：go install时会先进行编译，然后将编译后的二进制文件保存到第一个$GOPATH/bin目录下，将编译后的库文件放在$GOPATH/pkg目录下。go install时,首先要先进入到特定目录下，然后才能使用go install命令：
要么先进入到$GOPATH/src下，且只能对目录进行操作，不能对具体的go文件操作，因为go中包和目录名相同，但与go源文件名不一定相同。给go install指定一个目录名，就表示编译这个包名； 要么先进入项目目录下，然后直接go install，此时后面不加目录名（当前目录）。 go run：编译+运行，go run不会保留生成可执行的二进制文件，它实际上是将编译得到的文件放进一个临时目录，然后执行，执行完后自动清理临时目录。
go get：下载第三方包。不启用go module时，下载的第三方包存放在$GOPATH/pkg目录下，启用go module后，下载在$GOPATH/pkg/mod/目录下
go module go module是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。
相关环境变量 GO111MODULE 要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto。
GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。 GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。 GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9Cmongodb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9Cmongodb/</guid><description>go语言操作mongodb Install the MongoDB Go Driver The MongoDB Go Driver is made up of several packages. If you are just using go get, you can install the driver using:
go get github.com/mongodb/mongo-go-driver // go get github.com/mongodb/mongo-go-driver/mongo Example code package main import ( &amp;#34;context&amp;#34; //&amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/mongodb/mongo-go-driver/bson&amp;#34; &amp;#34;github.com/mongodb/mongo-go-driver/mongo&amp;#34; &amp;#34;github.com/mongodb/mongo-go-driver/mongo/options&amp;#34; &amp;#34;log&amp;#34; &amp;#34;time&amp;#34; ) func main() { // 连接数据库（方式1） ctx, _ := context.WithTimeout(context.Background(), 10*time.Second) // ctx opts := options.Client().ApplyURI(&amp;#34;mongodb://localhost:27017&amp;#34;) // opts client, _ := mongo.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/%E5%8F%8D%E5%B0%84reflect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/%E5%8F%8D%E5%B0%84reflect/</guid><description>转载：https://liwenzhou.com/posts/Go/13_reflect/
变量的内在机制 Go语言中的变量是分为两部分的:
类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。
支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。
Go程序在运行期使用reflect包访问程序的反射信息。
在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。
reflect包 在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value对象和Type对象。
TypeOf 在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func reflectType(x interface{}) { v := reflect.TypeOf(x) fmt.Printf(&amp;#34;type:%v\n&amp;#34;, v) } func main() { var a float32 = 3.14 reflectType(a) // type:float32 var b int64 = 100 reflectType(b) // type:int64 } type name和type kind 在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind），即一个Kind对应多个type。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) type myInt int64 func reflectType(x interface{}) { t := reflect.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/%E6%96%87%E4%BB%B6%E6%93%8D%E8%AF%BB%E5%86%99%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/%E6%96%87%E4%BB%B6%E6%93%8D%E8%AF%BB%E5%86%99%E4%BD%9C/</guid><description>文件操作 文件操作 主要有三个模块设计到了文件操作：os，bufio，ioutil。
​ 打开文件：os.Openfile()、os.Open()、os.Create()
​ 读写文件：无论使用os还是bufio模块进行读写，都需要先使用os模块打开文件
​ os：(直接对fd进行操作，读取操作可能会把多字节字符截断)
​ bufio：具有缓冲区，效率高。适合大文件读写。
​ ioutil无需事先打问文件，直接将整个文件拷贝到内存进行读写操作。适合小文件读写，例如配置文件。
package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;os&amp;#34; ) func method1() { //os模块 // 创建文件 // os.Create() 文件不存在则创建；文件存在则清空。 // 打开文件 //file, err := os.Open(&amp;#34;./test.txt&amp;#34;)　// os.Open()打开的文件只能用于读取，不能用于写入,等同于os.OpenFile(&amp;#34;./test.txt&amp;#34;,O_RDONLY,0) file, err := os.OpenFile(&amp;#34;./t1.txt&amp;#34;, os.O_RDWR|os.O_TRUNC|os.O_CREATE, 0666) // os.OpenFile()使用指定的模式(可以指定多种)和文件权限打开文件。 /* 指定模式： os.O_RDONLY 只读 os.O_WRONLY 只写 os.O_RDWR 读写 os.O_CREATE 创建 os.O_APPEND 追加（默认从文件头开始写入） os.O_TRUNC 清空 可以采用多种模式组合 os.O_WRONLY|os.O_CREATE　只写(从文件头开始写，会覆盖部分文件或全部文件)/新建 os.O_WRONLY|os.O_TRUNC|os.O_CREATE　只写（清空）/新建 os.O_RDWR|os.O_APPEND|os.O_CREATE 读写(追加)/新建 os.</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</guid><description>摘抄自：https://liwenzhou.com/posts/Go/12-interface/#autoid-1-6-0
接口值可能赋值为任意类型的值，那我们如何从接口值获取其存储的具体数据呢？
我们可以借助标准库fmt包的格式化打印获取到接口值的动态类型。
var m Mover m = &amp;amp;Dog{Name: &amp;#34;旺财&amp;#34;} fmt.Printf(&amp;#34;%T\n&amp;#34;, m) // *main.Dog m = new(Car) fmt.Printf(&amp;#34;%T\n&amp;#34;, m) // *main.Car 而fmt包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。关于反射的内容我们会在后续章节详细介绍。
而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。
x.(T) 其中：
x：表示接口类型的变量 T：表示断言x可能是的类型。 该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。
举个例子：
var n Mover = &amp;amp;Dog{Name: &amp;#34;旺财&amp;#34;} v, ok := n.(*Dog) if ok { fmt.Println(&amp;#34;类型断言成功&amp;#34;) v.Name = &amp;#34;富贵&amp;#34; // 变量v是*Dog类型 } else { fmt.Println(&amp;#34;类型断言失败&amp;#34;) } 如果对一个接口值有多个实际类型需要判断，推荐使用switch语句来实现。
// justifyType 对传入的空接口类型变量x进行类型断言 func justifyType(x interface{}) { switch v := x.(type) { case string: fmt.Printf(&amp;#34;x is a string，value is %v\n&amp;#34;, v) case int: fmt.</description></item></channel></rss>