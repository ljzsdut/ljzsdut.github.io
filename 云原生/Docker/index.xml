<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on ljzsdut</title><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/</link><description>Recent content in Docker on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker_registry%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker_registry%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</guid><description>转载：https://www.kancloud.cn/pshizhsysu/docker/1835364
概述 目录分为两层：blobs和repositories。
blobs：镜像所有内容的实际存储，包括了镜像层和镜像元信息manifest。 repositories是镜像元信息存储的地方，name代表仓库名称 每一个仓库下面又分为_layers、_manifests两个部分 _layers负责记录该仓库引用了哪些镜像层文件 _manifests负责记录镜像的元信息 revisions包含了仓库下曾经上传过的所有版本的镜像元信息 tags包含了仓库中的所有标签 current记录了当前标签指向的镜像 index目录则记录了标签指向的历史镜像 镜像其实就是一系列的由静态文件组成的层（layer），registry是如何存储镜像的呢？ registry会把与镜像有关的全部内容存到一个根目录下，根目录又分为两个目录，一个叫blobs，一个叫repositories。 先看blobs目录。在registry中，blobs可分为三类，一类是组成镜像的层（layer），一类是镜像的manifest文件，一类是镜像的manifest list文件。每一个文件都会计算出其sha256编码，然后用编码的前64位作为目录名建立一个目录，目录中只有一个名为data的文件，该文件中存储的就是相应的数据。把所有的64位编码的目录放在同一个根目录下就可以了，但是为了便于索引，再提取前两位，建立更高一层的目录。这样在所有的64位编码的目录中，前两位重复的就自然而然的放到同一个目录下。blobs目录的一个示例如下图所示： 然后是repositories目录，该目录的结构要比blobs目录复杂的多，repositories目录下首先是各个仓库组成的目录，每个仓库一个目录，目录的名字就是仓库的名字。 然后在每一个仓库下面都有三个目录，分别是：_layers,_manifests,_uploads 。 _uploads目录不用过多关注，当我们向registry上传镜像时，该目录会用来存放正在上传的镜像数据，上传结束后，所有数据会移动到blobs目录下，_uplpads目录就为空了。 而_layers,_manifests目录下全部都是link文件，这些link文件链接到blobs目录下的对应文件。之前说过，blobs目录下的文件分为三类：layer文件、manifest文件、manifest list文件。_layers目录下的link文件，与blobs目录下保存的属于该仓库镜像的layer文件一一对应。而_manifests目录又可分为两个子目录，一个是tags，一个是revisions，revisions目录下保存的就是所有版本的manifest文件和所有版本的manifest list文件的link文件。而tags目录则把该仓库按照镜像的不同版本进行分类（比如ubuntu仓库有20.04和18.04两个版本），每一个版本一个目录，每一个版本的目录下又有两个目录，一个是current，一个是index，current目录下保存的是当前版本的manifest文件的link文件，链接到blobs目录下的相应manifest文件。index目录是为了支持删除操作的，保存了当前版本的所有manifest文件的链接，当执行删除操作时，通过index目录可以将与该tag相关的所有blob进行删除。repositories目录的一个示例如下： 本地存储 环境 os: centos 7.3-1611 kernel: 4.16.13 docker-engine: 1.12.6 backend-filesystem: xfs(ftype=1) storage-driver: overlay2 镜像准备 首先从docker官网拉取镜像 library/registry:2.5.0，然后用其搭建一个私有镜像仓库 192.168.1.103:8021，然后再把该镜像上传到私有镜像仓库中
目录树 我们在主机A上pull镜像192.168.1.103:8021/library/registry:2.5.0，接下来，我们看这台主机上镜像的存储结构。主机A上docker的安装目录为/app/docker。
/app/docker`下有多个目录，与镜像相关的有两个：`image`与`overlay2 $ tree -L 1 /app/docker /app/docker ├── containers ├── image ├── network ├── overlay2 ├── swarm ├── tmp ├── trust └── volumes image的目录树如下： $ tree image image └── overlay2 ├── distribution │ ├── diffid-by-digest │ │ └── sha256 │ │ ├── 06ba8e23299fcf9dd9efb3c5acd4c9d03badac5392953001c75d38197113a63a │ │ ├── 2ee5ed28ffa762104505295c3c256c52a87fe8af0114b9e0198e9036495e10b8 │ │ ├── 802d2a9c64e8f556e510b4fe6c5378b9d49d8335a766d156ef21c7aeac64c9d6 │ │ ├── d1562c23a8aa4913a2fc720a3c478121f45d26597b58bbf9a29238276ca420a7 │ │ └── e110a4a1794126ef308a49f2d65785af2f25538f06700721aad8283b81fdfa58 │ └── v2metadata-by-diffid │ └── sha256 │ ├── 35039a507f7ae2cb74fd2405e6230036ee912588fcaac4d3c561774817590e97 │ ├── 3bb5bc5ad373d4855414158babfedcd81a8e27cca04a861a5640c7ec9079bcfb │ ├── 4fe15f8d0ae69e169824f25f1d4da3015a48feeeeebb265cd2e328e15c6a869f │ ├── aa3a31ee27f3d041998258e135f623696d2c21a63ddf798ae206322c7d518247 │ └── d00444e19d6513efe0e586094adb85fe5fc1c425d48e5b94263c65860a75d989 ├── imagedb │ ├── content │ │ └── sha256 │ │ └── c6c14b3960bdf9f5c50b672ff566f3dabd3e450b54ae5496f326898513362c98 │ └── metadata │ └── sha256 ├── layerdb │ ├── sha256 │ │ ├── 273edac7c3ab13711e95ed35a4eb397e10ae9b69c896c9ad28b64cb9097be327 │ │ │ ├── cache-id │ │ │ ├── diff │ │ │ ├── parent │ │ │ ├── size │ │ │ └── tar-split.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker%E5%85%A5%E9%97%A8/</guid><description>Docker入门 Docker入门 docker的感性认识 docker的优势 感受一下docker的便利性 一、docker的核心技术 Namespaces 1、UTS Namespace 2、IPC Namespace 3、PID Namespace 4、Network Namespace 5、Mount Namespace 6、User Namespace Cgroups 1、什么是 Cgroups 2、Cgroups的使用 UnionFS 1、什么是UnionFS 2、UnionFS在Images中的使用 二、docker网络 1、网络原理 2、模拟实现Docker网络 3、端口映射原理 三、docker使用 docker命令列表 docker search查找镜像 docker images查看本机已经存在的镜像 docker pull拉取镜像 docker push推送镜像 docker load从文件中导入镜像 docker save将镜像保存为归档文件 docker run 运行镜像，创建容器 docker start/stop/restart 启动、关闭、重启容器 docker ps 查看正在运行的容器 docker exec在容器内执行命令 docker rm删除容器 docker rmi删除镜像 docker commit从容器创建一个新的镜像 docker inspect查看镜像和容器的详细信息 docker cp宿主机、容器文件互拷 ☆☆☆、容器使用建议： 四、Dockefile指令 Dockerfile说明 FROM MAINTANIER(已废弃) LABEL RUN centos安装软件的最佳实践: alpine安装软件的最佳实践: CMD ENTRYPOINT EXPOSE ENV ARG ADD COPY VOLUME USER WORKDIR HEALTHCHECK SHELL STOPSIGNAL ONBUILD docker的感性认识 镜像与容器的关系？</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Docker%E4%B8%AD%E7%9A%84cgroup%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Docker%E4%B8%AD%E7%9A%84cgroup%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</guid><description>转载：https://www.jb51.net/article/230537.htm
前言 进程在系统中使用CPU、内存、磁盘等计算资源或者存储资源还是比较随心所欲的，我们希望对进程资源利用进行限制，对进程资源的使用进行追踪。这就让cgroup的出现成为了可能，它用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理。
什么是cgroup Linux CGroup(Linux Contral Group)，它其实是Linux内核的一个功能，它是Linux下的一种将进程按组进行管理的机制。最开始是由Google工程师Paul Menage和Rohit Seth于2006年发起的，最早起名叫进程容器。在2007之后随着容器得提出，为了避免混乱重命名为cgroup，并且被合并到了内核2.6.24版本中去了。 在用户层看来，cgroup技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个subsystem关联。树主要用来将进程进行分组，而subsystem用来对这些组进行操作。
cgroup的组成 cgroup主要包含以下两个部分
subsystem： 一个subsystem就是一个内核模块，它被关联到一颗cgroup树之后，就会在树节点进行具体的操作。subsystem经常被称作&amp;quot;resource controller&amp;quot;，因为它主要被用来调度或者限制每个进程组的资源，但是这个说法不完全准确，因为有时我们将进程分组只是为了做一些监控，观察一下他们的状态，比如perf_event subsystem。 hierarchy：一个hierarchy可以理解为一棵cgroup树，树的每个节点就是一个进程组，每棵树都会与多个subsystem关联。在一颗树里面，会包含Linux系统中的所有进程，但每个进程只能属于一个节点（进程组）。系统中可以有很多颗cgroup树，每棵树都和不同的subsystem关联，一个进程可以属于多颗树，即一个进程可以属于多个进程组，这些进程组和不同的subsystem关联。 可以通过查看/proc/cgroup目录查看当前系统支持哪些subsystem关联
第一列：表示subsystem名
第二列：表示关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么它们的这个字段将一样。比如图中的cpuset、cpu和cpuacct。
第三列：表示subsystem所关联的cgroup树中进程组的个数，即树上节点的个数。
cgroup提供的功能 它提供了如下功能
Resource limitation:资源使用限制 Prioritization:优先级控制 Accounting:一些审计或者统计 Control:挂起进程，恢复执行进程 一般我们可以用cgroup做以下事情
隔离一个进程集合（比如MySQL的所有进程），限定他们所占用的资源，比如绑定的核限制 为这组进程分配内存 为这组进程的分配足够的带宽及进行存储限制 限制访问某些设备 cgroup在Linux中表现为一个文件系统，运行如下命令
mount成功后，可以看到，在/sys/fs下有个cgroup目录,这个目录下有很多子系统。比如cpu、cpuset、blkio等。 然后在/sys/fs/cgroup/cpu目录下建个子目录test,这个时候会发现在该目录下多了很多文件
限制cgroup中的CPU 在cgroup里面，跟CPU相关的子系统有cpusets、cpuacct和cpu。 其中cpuset主要用于设置CPU的亲和性，可以限制cgroup中的进程只能在指定的CPU上运行，或者不能在指定的CPU上运行，同时cpuset还能设置内存的亲和性。cpuacct包含当前cgroup所使用的CPU的统计信息。这里我们只说以下cpu。
然后我们在/sys/fs/cgroup/cpu下创建一个子group, 该目录下文件列表
cpu.cfs_period_us用来配置时间周期长度，cpu.cfs_quota_us用来配置当前cgroup在设置的周期长度内所能使用的CPU时间数，两个文件配合起来设置CPU的使用上限。两个文件的单位都是微秒（us），cpu.cfs_period_us的取值范围为1毫秒（ms）到1秒（s），cpu.cfs_quota_us的取值大于1ms即可。 下面来举个例子讲解如何使用cpu限制 假如我们写了一个死循环
运行起来用top查看下占用率达到了100%
我们执行如下命令对cfs_quota_us进行设置
echo` `20000 &amp;gt; ``/sys/fs/cgroup/cpu/test/cpu``.cfs_quota_us 这条命令表示把进程的CPU利用率下降20%，然后把进程PID加入到cgroup中
再执行top可以看到cpu利用率下降了
限制cgroup中的内存 代码如果有bug，比如内存泄露等会榨干系统内存，让其它程序由于分配不了足够的内存而出现异常，如果系统配置了交换分区，会导致系统大量使用交换分区，从而系统运行很慢。 而cgroup对进程内存控制主要控制如下：
限制cgroup中所有进程使用的内存总量 限制cgroup中所有进程使用的物理内容+swap交换总量 限制cgroup中所有进程所能使用的内核内存总量及其它一些内核资源(CONFIG_MEMCG_KMEM)。 这里限制内核内存就是限制cgroup当前所使用的内核资源，包括当前进程的内核占空间，socket所占用的内存空间等。当内存吃紧时，可以阻止当前cgroup继续创建进程以及向内核申请分配更多的内核资源。
下面通过一个例子带大家理解cgroup做内存控制的
#include &amp;lt;iostream&amp;gt;``#include &amp;lt;sys/types.h&amp;gt;``#include &amp;lt;cstdlib&amp;gt;``#include &amp;lt;cstdio&amp;gt;``#include &amp;lt;string.h&amp;gt;``#include &amp;lt;unistd.h&amp;gt;` `#define CHUNK_SIZE 512` `int` `main()``{`` ``int` `size = 0;`` ``char` `*p = nullptr; `` ``while``(1)`` ``{`` ``if``((p = (``char``*)``malloc``(CHUNK_SIZE))==nullptr)`` ``{`` ``break``;`` ``}` ` ``memset``(p, 0, CHUNK_SIZE);`` ``printf``(``&amp;#34;[%u]-- [%d]MB is allocated &amp;#34;``, getpid(), ++size);`` ``sleep(1);`` ``}`` ` ` ``return` `0;``} 首先，在/sys/fs/cgroup/memory下创建一个子目录即创建了一个子cgroup，比如这里我们创建了一个test目录</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E5%8F%8C%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E5%8F%8C%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95/</guid><description>说明：
制作双架构镜像，Docker客户端版本需要大于18.03。
构建双架构镜像的本质是先分别构建x86和ARM架构的镜像，然后通过构建双架构的镜像manifest。
例如已经构建好了defaultbackend-linux-amd64:1.5和defaultbackend-linux-arm64:1.5两个镜像，分别是x86架构和ARM架构。
将这两个镜像上传到SWR镜像仓库，如下所示。上传镜像的具体方法请参见客户端上传镜像。
# 给原始amd64镜像defaultbackend-linux-amd64:1.5加tag docker tag defaultbackend-linux-amd64:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 # 给原始arm64镜像defaultbackend-linux-arm64:1.5加tag docker tag defaultbackend-linux-arm64:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 # 上传amd64镜像至swr镜像仓库 docker push swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 # 上传arm64镜像至swr镜像仓库 docker push swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 创建双架构manifest文件并上传。
# 开启DOCKER_CLI_EXPERIMENTAL export DOCKER_CLI_EXPERIMENTAL=enabled # 创建镜像manifest文件 docker manifest create --amend --insecure swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 # 给镜像manifest文件添加arch信息 docker manifest annotate swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 --arch amd64 docker manifest annotate swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 --arch arm64 # 向swr镜像仓库推送镜像manifest docker manifest push -p --insecure swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 这样在创建负载时就只需要使用swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5这个镜像地址。
当Pod调度到x86架构的节点时，会拉取swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5这个镜像。 当Pod调度到ARM架构的节点时，会拉取swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5这个镜像。 参考文档：</description></item></channel></rss>