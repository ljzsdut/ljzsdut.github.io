<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on ljzsdut</title><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/</link><description>Recent content in Docker on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker_registry%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker_registry%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</guid><description>转载：https://www.kancloud.cn/pshizhsysu/docker/1835364
概述 目录分为两层：blobs和repositories。
blobs：镜像所有内容的实际存储，包括了镜像层和镜像元信息manifest。 repositories是镜像元信息存储的地方，name代表仓库名称 每一个仓库下面又分为_layers、_manifests两个部分 _layers负责记录该仓库引用了哪些镜像层文件 _manifests负责记录镜像的元信息 revisions包含了仓库下曾经上传过的所有版本的镜像元信息 tags包含了仓库中的所有标签 current记录了当前标签指向的镜像 index目录则记录了标签指向的历史镜像 镜像其实就是一系列的由静态文件组成的层（layer），registry是如何存储镜像的呢？ registry会把与镜像有关的全部内容存到一个根目录下，根目录又分为两个目录，一个叫blobs，一个叫repositories。 先看blobs目录。在registry中，blobs可分为三类，一类是组成镜像的层（layer），一类是镜像的manifest文件，一类是镜像的manifest list文件。每一个文件都会计算出其sha256编码，然后用编码的前64位作为目录名建立一个目录，目录中只有一个名为data的文件，该文件中存储的就是相应的数据。把所有的64位编码的目录放在同一个根目录下就可以了，但是为了便于索引，再提取前两位，建立更高一层的目录。这样在所有的64位编码的目录中，前两位重复的就自然而然的放到同一个目录下。blobs目录的一个示例如下图所示： 然后是repositories目录，该目录的结构要比blobs目录复杂的多，repositories目录下首先是各个仓库组成的目录，每个仓库一个目录，目录的名字就是仓库的名字。 然后在每一个仓库下面都有三个目录，分别是：_layers,_manifests,_uploads 。 _uploads目录不用过多关注，当我们向registry上传镜像时，该目录会用来存放正在上传的镜像数据，上传结束后，所有数据会移动到blobs目录下，_uplpads目录就为空了。 而_layers,_manifests目录下全部都是link文件，这些link文件链接到blobs目录下的对应文件。之前说过，blobs目录下的文件分为三类：layer文件、manifest文件、manifest list文件。_layers目录下的link文件，与blobs目录下保存的属于该仓库镜像的layer文件一一对应。而_manifests目录又可分为两个子目录，一个是tags，一个是revisions，revisions目录下保存的就是所有版本的manifest文件和所有版本的manifest list文件的link文件。而tags目录则把该仓库按照镜像的不同版本进行分类（比如ubuntu仓库有20.04和18.04两个版本），每一个版本一个目录，每一个版本的目录下又有两个目录，一个是current，一个是index，current目录下保存的是当前版本的manifest文件的link文件，链接到blobs目录下的相应manifest文件。index目录是为了支持删除操作的，保存了当前版本的所有manifest文件的链接，当执行删除操作时，通过index目录可以将与该tag相关的所有blob进行删除。repositories目录的一个示例如下： 本地存储 环境 os: centos 7.3-1611 kernel: 4.16.13 docker-engine: 1.12.6 backend-filesystem: xfs(ftype=1) storage-driver: overlay2 镜像准备 首先从docker官网拉取镜像 library/registry:2.5.0，然后用其搭建一个私有镜像仓库 192.168.1.103:8021，然后再把该镜像上传到私有镜像仓库中
目录树 我们在主机A上pull镜像192.168.1.103:8021/library/registry:2.5.0，接下来，我们看这台主机上镜像的存储结构。主机A上docker的安装目录为/app/docker。
/app/docker`下有多个目录，与镜像相关的有两个：`image`与`overlay2 $ tree -L 1 /app/docker /app/docker ├── containers ├── image ├── network ├── overlay2 ├── swarm ├── tmp ├── trust └── volumes image的目录树如下： $ tree image image └── overlay2 ├── distribution │ ├── diffid-by-digest │ │ └── sha256 │ │ ├── 06ba8e23299fcf9dd9efb3c5acd4c9d03badac5392953001c75d38197113a63a │ │ ├── 2ee5ed28ffa762104505295c3c256c52a87fe8af0114b9e0198e9036495e10b8 │ │ ├── 802d2a9c64e8f556e510b4fe6c5378b9d49d8335a766d156ef21c7aeac64c9d6 │ │ ├── d1562c23a8aa4913a2fc720a3c478121f45d26597b58bbf9a29238276ca420a7 │ │ └── e110a4a1794126ef308a49f2d65785af2f25538f06700721aad8283b81fdfa58 │ └── v2metadata-by-diffid │ └── sha256 │ ├── 35039a507f7ae2cb74fd2405e6230036ee912588fcaac4d3c561774817590e97 │ ├── 3bb5bc5ad373d4855414158babfedcd81a8e27cca04a861a5640c7ec9079bcfb │ ├── 4fe15f8d0ae69e169824f25f1d4da3015a48feeeeebb265cd2e328e15c6a869f │ ├── aa3a31ee27f3d041998258e135f623696d2c21a63ddf798ae206322c7d518247 │ └── d00444e19d6513efe0e586094adb85fe5fc1c425d48e5b94263c65860a75d989 ├── imagedb │ ├── content │ │ └── sha256 │ │ └── c6c14b3960bdf9f5c50b672ff566f3dabd3e450b54ae5496f326898513362c98 │ └── metadata │ └── sha256 ├── layerdb │ ├── sha256 │ │ ├── 273edac7c3ab13711e95ed35a4eb397e10ae9b69c896c9ad28b64cb9097be327 │ │ │ ├── cache-id │ │ │ ├── diff │ │ │ ├── parent │ │ │ ├── size │ │ │ └── tar-split.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker%E5%85%A5%E9%97%A8/</guid><description>Docker入门 [TOC]
docker的感性认识 镜像与容器的关系？
docker容器就是一个虚拟机。（不准确！！！）
每个虚拟化应用程序不仅包括应用程序（可能只有数十MB）以及必要的二进制文件和库，还包括整个客户机操作系统（可能重数十GB）。
Docker容器仅包含应用程序及其依赖项。它在主机操作系统上的用户空间中作为隔离进程运行，与其他容器共享内核。因此，它具有虚拟机的资源隔离和分配优势，而且具有更高的可移植性和效率。
docker的优势 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。
1.更高效的利用系统资源
docker对系统资源的利用率更高，无论是应用执行速度，内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机往往可以运行更多数量的应用。
2.更快速的启动时间
传统的虚拟机技术启动应用服务往往需要数分钟，而docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级，甚至毫秒级的启动时间，大大的节约了开发测试，部署的时间。
3.一致的运行环境
开发过程中常见的一个问题是环境一致问题，由于开发环境，测试环境，生产环境不一致，导致有些bug并未在开发过程中发现。而docker的镜像提供了除内核外完整的运行时环境（库、依赖），确保环境一致性，从而不会在出现“这段代码在我机器上没问题”这类问题。
4.持续支付和部署
docker不像传统的软件交付方式那样，只把代码以及说明文档之类的给你就完了，而是直接给你一个docker镜像作为标准的交付件，这个标准件不仅包括了应用代码本身，还包括了代码运行需要的OS等整体依赖环境。
对开发和运维人员来说，最希望就是一次创建和部署，可以在任意的地方运行。
使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署(Continuous Delivery/Deployment) 系统进行自动部署。
而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。
5.更轻松的迁移
由于docker确保了执行环境的一致性，使得应用的迁移更加的容易。docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云、甚至是笔记本、其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。
6.更轻松的维护和拓展
docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得十分简单。此外，docker团队同各个开源项目团队一起维护了一大批高质量的官网镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。
对比传统虚拟机总结
特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 感受一下docker的便利性 Docker安装文档
k8s文档中关于docker安装
案例1：为了保证宿主机的纯净，启动一个linux环境:
docker run -it -d centos 案例2：部署nginx
docker run -d -p 80:80 nginx:1.14-alpine 案例3： 部署MySQL5.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Docker%E4%B8%AD%E7%9A%84cgroup%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Docker%E4%B8%AD%E7%9A%84cgroup%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</guid><description>转载：https://www.jb51.net/article/230537.htm
前言 进程在系统中使用CPU、内存、磁盘等计算资源或者存储资源还是比较随心所欲的，我们希望对进程资源利用进行限制，对进程资源的使用进行追踪。这就让cgroup的出现成为了可能，它用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理。
什么是cgroup Linux CGroup(Linux Contral Group)，它其实是Linux内核的一个功能，它是Linux下的一种将进程按组进行管理的机制。最开始是由Google工程师Paul Menage和Rohit Seth于2006年发起的，最早起名叫进程容器。在2007之后随着容器得提出，为了避免混乱重命名为cgroup，并且被合并到了内核2.6.24版本中去了。 在用户层看来，cgroup技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个subsystem关联。树主要用来将进程进行分组，而subsystem用来对这些组进行操作。
cgroup的组成 cgroup主要包含以下两个部分
subsystem： 一个subsystem就是一个内核模块，它被关联到一颗cgroup树之后，就会在树节点进行具体的操作。subsystem经常被称作&amp;quot;resource controller&amp;quot;，因为它主要被用来调度或者限制每个进程组的资源，但是这个说法不完全准确，因为有时我们将进程分组只是为了做一些监控，观察一下他们的状态，比如perf_event subsystem。 hierarchy：一个hierarchy可以理解为一棵cgroup树，树的每个节点就是一个进程组，每棵树都会与多个subsystem关联。在一颗树里面，会包含Linux系统中的所有进程，但每个进程只能属于一个节点（进程组）。系统中可以有很多颗cgroup树，每棵树都和不同的subsystem关联，一个进程可以属于多颗树，即一个进程可以属于多个进程组，这些进程组和不同的subsystem关联。 可以通过查看/proc/cgroup目录查看当前系统支持哪些subsystem关联
第一列：表示subsystem名
第二列：表示关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么它们的这个字段将一样。比如图中的cpuset、cpu和cpuacct。
第三列：表示subsystem所关联的cgroup树中进程组的个数，即树上节点的个数。
cgroup提供的功能 它提供了如下功能
Resource limitation:资源使用限制 Prioritization:优先级控制 Accounting:一些审计或者统计 Control:挂起进程，恢复执行进程 一般我们可以用cgroup做以下事情
隔离一个进程集合（比如MySQL的所有进程），限定他们所占用的资源，比如绑定的核限制 为这组进程分配内存 为这组进程的分配足够的带宽及进行存储限制 限制访问某些设备 cgroup在Linux中表现为一个文件系统，运行如下命令
mount成功后，可以看到，在/sys/fs下有个cgroup目录,这个目录下有很多子系统。比如cpu、cpuset、blkio等。 然后在/sys/fs/cgroup/cpu目录下建个子目录test,这个时候会发现在该目录下多了很多文件
限制cgroup中的CPU 在cgroup里面，跟CPU相关的子系统有cpusets、cpuacct和cpu。 其中cpuset主要用于设置CPU的亲和性，可以限制cgroup中的进程只能在指定的CPU上运行，或者不能在指定的CPU上运行，同时cpuset还能设置内存的亲和性。cpuacct包含当前cgroup所使用的CPU的统计信息。这里我们只说以下cpu。
然后我们在/sys/fs/cgroup/cpu下创建一个子group, 该目录下文件列表
cpu.cfs_period_us用来配置时间周期长度，cpu.cfs_quota_us用来配置当前cgroup在设置的周期长度内所能使用的CPU时间数，两个文件配合起来设置CPU的使用上限。两个文件的单位都是微秒（us），cpu.cfs_period_us的取值范围为1毫秒（ms）到1秒（s），cpu.cfs_quota_us的取值大于1ms即可。 下面来举个例子讲解如何使用cpu限制 假如我们写了一个死循环
运行起来用top查看下占用率达到了100%
我们执行如下命令对cfs_quota_us进行设置
echo` `20000 &amp;gt; ``/sys/fs/cgroup/cpu/test/cpu``.cfs_quota_us 这条命令表示把进程的CPU利用率下降20%，然后把进程PID加入到cgroup中
再执行top可以看到cpu利用率下降了
限制cgroup中的内存 代码如果有bug，比如内存泄露等会榨干系统内存，让其它程序由于分配不了足够的内存而出现异常，如果系统配置了交换分区，会导致系统大量使用交换分区，从而系统运行很慢。 而cgroup对进程内存控制主要控制如下：
限制cgroup中所有进程使用的内存总量 限制cgroup中所有进程使用的物理内容+swap交换总量 限制cgroup中所有进程所能使用的内核内存总量及其它一些内核资源(CONFIG_MEMCG_KMEM)。 这里限制内核内存就是限制cgroup当前所使用的内核资源，包括当前进程的内核占空间，socket所占用的内存空间等。当内存吃紧时，可以阻止当前cgroup继续创建进程以及向内核申请分配更多的内核资源。
下面通过一个例子带大家理解cgroup做内存控制的
#include &amp;lt;iostream&amp;gt;``#include &amp;lt;sys/types.h&amp;gt;``#include &amp;lt;cstdlib&amp;gt;``#include &amp;lt;cstdio&amp;gt;``#include &amp;lt;string.h&amp;gt;``#include &amp;lt;unistd.h&amp;gt;` `#define CHUNK_SIZE 512` `int` `main()``{`` ``int` `size = 0;`` ``char` `*p = nullptr; `` ``while``(1)`` ``{`` ``if``((p = (``char``*)``malloc``(CHUNK_SIZE))==nullptr)`` ``{`` ``break``;`` ``}` ` ``memset``(p, 0, CHUNK_SIZE);`` ``printf``(``&amp;#34;[%u]-- [%d]MB is allocated &amp;#34;``, getpid(), ++size);`` ``sleep(1);`` ``}`` ` ` ``return` `0;``} 首先，在/sys/fs/cgroup/memory下创建一个子目录即创建了一个子cgroup，比如这里我们创建了一个test目录</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E5%8F%8C%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E5%8F%8C%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95/</guid><description>说明：
制作双架构镜像，Docker客户端版本需要大于18.03。
构建双架构镜像的本质是先分别构建x86和ARM架构的镜像，然后通过构建双架构的镜像manifest。
例如已经构建好了defaultbackend-linux-amd64:1.5和defaultbackend-linux-arm64:1.5两个镜像，分别是x86架构和ARM架构。
将这两个镜像上传到SWR镜像仓库，如下所示。上传镜像的具体方法请参见客户端上传镜像。
# 给原始amd64镜像defaultbackend-linux-amd64:1.5加tag docker tag defaultbackend-linux-amd64:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 # 给原始arm64镜像defaultbackend-linux-arm64:1.5加tag docker tag defaultbackend-linux-arm64:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 # 上传amd64镜像至swr镜像仓库 docker push swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 # 上传arm64镜像至swr镜像仓库 docker push swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 创建双架构manifest文件并上传。
# 开启DOCKER_CLI_EXPERIMENTAL export DOCKER_CLI_EXPERIMENTAL=enabled # 创建镜像manifest文件 docker manifest create --amend --insecure swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 # 给镜像manifest文件添加arch信息 docker manifest annotate swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5 --arch amd64 docker manifest annotate swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5 --arch arm64 # 向swr镜像仓库推送镜像manifest docker manifest push -p --insecure swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5 这样在创建负载时就只需要使用swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend:1.5这个镜像地址。
当Pod调度到x86架构的节点时，会拉取swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-amd64:1.5这个镜像。 当Pod调度到ARM架构的节点时，会拉取swr.cn-north-4.myhuaweicloud.com/test-namespace/defaultbackend-linux-arm64:1.5这个镜像。 参考文档：</description></item></channel></rss>