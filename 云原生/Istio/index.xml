<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Istio on ljzsdut</title><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/</link><description>Recent content in Istio on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/00-istio%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/00-istio%E5%85%A5%E9%97%A8/</guid><description>istioctl istioctl是istio的一个命令行管理工具，类似k8s的kubectl工具。
安装 直接拷贝二进制文件即可。
https://github.com/istio/istio/releases/tag/1.5.2
或
curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.5.2 TARGET_ARCH=x86_64 sh - 命令行补全 #bash source tools/istioctl.bash #zsh source tools/_istioctl istio 安装 istio可以使用istioctl进行安装，也可以使用helm进行。
istio可以安装不同的profile，代表不同的功能集合。
下面使用profile=demo使用istioctl进行：
istioctl manifest apply --set profile=demo #prod建议使用profile=default，减少不必要的组件，提供性能 查看profile列表：
istioctl profile list
安装完成后，所有组件会安装在istio-system名称空间中。
卸载 istioctl manefest generate --set profile=demo |kubectl delete -f - 架构 Envoy Istio 使用 Envoy 代理的扩展版本。Envoy 是用 C++ 开发的高性能代理，用于协调服务网格中所有服务的入站和出站流量。Envoy代理是唯一与数据平面流量交互的 Istio 组件。
Envoy代理中有2个进程：pilot-agent、envoy
Envoy 代理被部署为服务的 sidecar，在逻辑上为服务增加了 Envoy 的许多内置特性，例如:
动态服务发现 负载均衡 TLS 终端 HTTP/2 与 gRPC 代理 熔断器 健康检查 基于百分比流量分割的分阶段发布 故障注入 丰富的指标 这种 sidecar 部署允许 Istio 提取大量关于流量行为的信号作为属性。Istio 可以使用这些属性来实施策略决策，并将其发送到监视系统以提供有关整个网格行为的信息。</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/00-%E6%9D%82%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/00-%E6%9D%82%E8%AE%B0/</guid><description>建议为 Pod 模板加入两个标签 : app 和 version。 deployment无论是否进行服务暴露，都必须有一个service。 VirtualService中创建默认的路由规则 :不论是否进行进一步的流量控制，都建议为网格中的服务创建默认的路由规则 ，以防发生意料之外的访问 结果 。没有做match的匹配条件且位于最好的一个匹配规则就是默认规则。 Service 对象中 的 Port 部分必须以“ 协议名”为前缀，目前支持 的协议名包括 http、 http2、 mongo、 redis 和 grpc，例如 ，我们的 flaskapp 中的服务端口就被命名 为“http”。 Istio会根据这些命名来确定为这些端口提供什么样的服务 ，不符合命名 规范的端口会被当作 TCP 服务，其功能支持范围会大幅缩小 。 envoy教程：https://www.qikqiak.com/envoy-book/</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/01-istio-CRD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/01-istio-CRD/</guid><description>Istio-CRD 《云原生服务网格Istio：原理、实践、架构与源码解析 - 张超盟 等(2019)》
类比nginx，istio的crd可以理解为envoy的配置文件片段，这些片段有pilot转换生成envoy真正可用的配置，让envoy来加载使用。
nginx.conf ---&amp;gt; nginx virtual-service(crd) ---&amp;gt; envoy 虚拟服务 目标规则 网关 服务入口 Sidecar VirtualService 参考文档：https://istio.io/latest/zh/docs/concepts/traffic-management/#virtual-services
虚拟服务：定义路由规则。描述满足条件的请求去哪里。描述的主体是一个服务，而不是一组规则。该服务中包含了路由规则。
VirtualService定义了访问地址和路由目标的联系，它将流量如何路由到给定目标地址。(对特定的目标进行定义路由规则)
一个不是很准确的理解：VirtualService可以理解为是k8s中的Service的替代品（替换host指定的k8s的Service），不过这个替代品只要在网格内的请求才会使用（请求的发起端和接收端都在网格内）。如果不是服务网格内的请求，则会使用原生的k8s的Service。之所以说不准确，是指host不仅仅是指k8s中的Service，也可能是ingress-gateway中定义的host，也可能是通配符“*”或通配符“*”前缀。
apiVersion: networking.istio.io/v1alpha3 kind: VirtualService #本质上是envoy的配置文件片段。定义了访问hosts中指定的目标服务时，如何路由 metadata: name: reviews spec: hosts: #请求的目标服务地址(流量发送的目标)，类似于nginx上的虚拟主机的域名：如果在服务网格内的请求这个host时，就会请求这个vs，这个vs中的路由规则会生效（即服务网格中对这个host的请求，VirtualService替代了k8s的Service）。 - reviews #host可以是k8s中的svc、istio的ingressgateway中定义的host或通配符“*”（或前缀）。表示访问这个host的请求将被应用下面定义的路由规则。如果是短域名，会补全VirtualService所在的名称空间。 gateways: #表示应用这些路由规则的gateway。 #VirtualService 描述的规则可以作用到网格里的Sidecar和入口处的Gateway，表示将路由规则应用于网格内的访问还是网格外经过Gateway的访问。 #如果服务只是在网格内访问的，gateways字段可以省略。定义的规则只作用到网格内的Sidecar。（最常用的场景） #如果服务只是在网格外访问的。配置要关联的Gateway，表示对应Gateway进来的流量执行在这个VirtualService上定义的流量规则。 #如果在服务网格内和网格外都需要访问。这里要给这个数组字段至少写两个元素，一个是外部访问的Gateway，另一个是保留关键字“mesh”。使用中的常见问题是忘了配置“mesh”这个常量而导致错。 - ext-host-gwy #Gateway名称，（也可以写为ext-host-gwy.istio-system.svc.cluster.local？） - mesh #保留关键字“mesh”，表示来自网格内访问 http: #定义http路由规则：多个匹配路由规则，从上往下，依次匹配，匹配到就结束，不再匹配后续的匹配规则（匹配到的第1个规则生效） - match: - headers: end-user: exact: jason route: - destination: #请求目标，最终的流量要被送到这个目标上。是由DestinationRule定义，可以是Destination中定义的服务，也可以是Destination中定义的服务子集。 host: reviews #host表示在Istio 中注册的服务名，不但包括网格内的服务，也包括通过ServiceEntry方式注册的外部服务。在Kubernetes平台上如果用到短域名，Istio 就会根据规则的命名空间解 subset: v2 #表示在host上定义的一个子集 - route: #缺省match条件，表示都匹配。 - destination: host: reviews subset: v3 #exportTo: #（6） exportTo用于控制VirtualService 跨命名空间的可见性，这样就可以控制在一个命名空间下定义的VirtualService是否可以被其他命名空间下的Sidecar和Gateway使用了。如果未赋值，则默认全局可见。“.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/02-virtualService/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Istio/02-virtualService/</guid><description>VirtualService 官方文档：https://istio.io/latest/zh/docs/reference/config/networking/
配置如何影响流量路由到哪一个Service。
Field Type Description Required hosts string[] 1、流量的访问入口标识。可以是IP，也可以是DNS名字(可使用通配符)。
2、如果是短名称，会自动补全（根据istio所在平台特性）。如果是k8s平台，会自动填充上VirtualService所在的名称空间，而不是根据目标Service所在的名称空间。 Yes gateways string[] 该VirtualService路由规则适应于哪些gateways和sidecars。 No http HTTPRoute[] http流量的路由规则 No tls TLSRoute[] 未终止的tls流量(TLS/HTTPS)的路由规则 No tcp TCPRoute[] tcp流量路由规则 No exportTo string[] 导出虚拟服务允许其被哪些其他名称空间中定义的边车和网关使用。 No http apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews-route-two-domains spec: hosts: - reviews.com http: - route: - destination: host: dev.reviews.com weight: 25 - destination: host: reviews.com weight: 75 tls apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: bookinfo-sni spec: hosts: - &amp;#34;*.</description></item></channel></rss>