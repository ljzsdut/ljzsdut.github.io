<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>运维实战 on ljzsdut</title><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/</link><description>Recent content in 运维实战 on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/%E9%9B%86%E7%BE%A4node%E7%9A%84load%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/%E9%9B%86%E7%BE%A4node%E7%9A%84load%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5/</guid><description>第一步：定位问题进程 Linux load average 高的&amp;quot;元凶&amp;quot; 如何找出系统中load高时处于运行队列的进程
系统有很高的负载但是CPU使用率却很低，或者负载很低而CPU利用率很高，这两者没有直接关系，如何用脚本统计出来处于运行队列的进程呢？
每隔1s统计一次：
#!/bin/bash LANG=C PATH=/sbin:/usr/sbin:/bin:/usr/bin interval=1 length=86400 for i in $(seq 1 $(expr ${length} / ${interval}));do date LANG=C ps -eTo stat,pid,tid,ppid,comm --no-header | sed -e &amp;#39;s/^ \*//&amp;#39; | perl -nE &amp;#39;chomp;say if (m!^\S*[RD]+\s*!)&amp;#39; date cat /proc/loadavg echo -e &amp;#34;\n&amp;#34; sleep ${interval} done 从统计出来的结果可以看到：
注：R代表运行中的队列，D是不可中断的睡眠进程
在load比较高的时候，有大量的java处于R或者D状态，他们才是造成load上升的元凶，和我们底层的负载确实是没有关系的。而这个进程的PID为“18440”.
Linux CPU使用率高的&amp;quot;元凶&amp;quot; 查CPU使用率比较高的线程小脚本：
#!/bin/bash LANG=C PATH=/sbin:/usr/sbin:/bin:/usr/bin interval=1 length=86400 for i in $(seq 1 $(expr ${length} / ${interval}));do date LANG=C ps -eT -o%cpu,pid,tid,ppid,comm | grep -v CPU | sort -n -r | head -20 date LANG=C cat /proc/loadavg { LANG=C ps -eT -o%cpu,pid,tid,ppid,comm | sed -e &amp;#39;s/^ *//&amp;#39; | tr -s &amp;#39; &amp;#39; | grep -v CPU | sort -n -r | cut -d &amp;#39; &amp;#39; -f 1 | xargs -I{} echo -n &amp;#34;{} + &amp;#34; &amp;amp;&amp;amp; echo &amp;#39; 0&amp;#39;; } | bc -l sleep ${interval} done fuser -k $0 第二步：定位问题容器 docker 在宿主机上根据进程PID查找归属容器ID 参考：https://www.</description></item></channel></rss>