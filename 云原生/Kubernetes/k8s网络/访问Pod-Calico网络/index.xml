<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Calico网络 on ljzsdut</title><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/</link><description>Recent content in Calico网络 on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-Calico%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-Calico%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/</guid><description>原文：https://tanzu.vmware.com/developer/guides/container-networking-calico-refarch/
概述 Calico 是一个 CNI 插件，为 Kubernetes 集群提供容器网络。它使用 Linux 原生工具来促进流量路由和执行网络策略。它还托管一个 BGP 守护进程，用于将路由分发到其他节点。Calico 的工具作为 DaemonSet 在 Kubernetes 集群上运行。这使管理员能够安装 Calico， kubectl apply -f ${CALICO_MANIFESTS}.yaml而无需设置额外的服务或基础设施。
架构建议 使用 Kubernetes 数据存储。 安装 Typha 以确保数据存储可扩展性。 对单个子网集群不使用封装。 对于多子网集群，在 CrossSubnet 模式下使用 IP-in-IP。 根据网络 MTU 和选择的路由模式配置 Calico MTU。 为能够增长到 50 个以上节点的集群添加全局路由反射器。 将 GlobalNetworkPolicy 用于集群范围的入口和出口规则。通过添加 namespace-scoped 来修改策略NetworkPolicy。 Calico组件 [root@k8s-1 ~]# kubectl get pods -o wide -A| grep calico kube-system calico-kube-typha-69496dddsde 1/1 Running 1 123d 10.244.231.129 k8s-1 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; kube-system calico-kube-controllers-69496d8b75-tvgzw 1/1 Running 1 123d 10.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC2/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC3/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC4/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC5/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/001-%E7%9A%84%E5%89%AF%E6%9C%AC6/</guid><description/></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/1-Calico%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98-Pod%E6%B5%81%E9%87%8F%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%BD%91%E5%8D%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/1-Calico%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98-Pod%E6%B5%81%E9%87%8F%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%BD%91%E5%8D%A1/</guid><description>Calico 网络通信原理揭秘 Calico 是一个纯三层的数据中心网络方案，而且无缝集成像 OpenStack 这种 Iaas 云架构，能够提供可控的 VM、容器、裸机之间的 IP 通信。为什么说它是纯三层呢？因为所有的数据包都是通过路由的形式找到对应的主机和容器的，然后通过BGP协议来将所有路由同步到所有的机器或数据中心，从而完成整个网络的互联。
简单来说，Calico在主机上创建了一堆的veth pair，其中一端在主机上，另一端在容器的网络命名空间里，然后在容器和主机中分别设置几条路由，来完成网络的互联。
1.Calico网络模型揭秘 下面我们通过具体的例子来帮助大家理解Calico网络的通信原理。任意选择 k8s 集群中的一个节点作为实验节点，进入容器 A，查看容器 A 的 IP 地址：
$ ip a 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 3: eth0@if771: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1440 qdisc noqueue state UP link/ether 66:fb:34:db:c9:b4 brd ff:ff:ff:ff:ff:ff inet 172.17.8.2/32 scope global eth0 valid_lft forever preferred_lft forever 这里容器获取的是 /32 位主机地址，表示将容器 A 作为一个单点的局域网，没有其他IP与其在同一个子网中。所以直接查询默认路由，将二层转换为三层。</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/2-Calico%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/2-Calico%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F/</guid><description>Calico 是一个纯三层的数据中心网络方案，为什么说它是纯三层呢？因为所有的数据包都是通过路由的形式找到对应的主机和容器的，然后通过 BGP 协议来将所有路由同步到所有的机器或数据中心，从而完成整个网络的互联。
简单来说，Calico 在主机上创建了一堆的 veth pair，其中一端在主机上，另一端在容器的网络命名空间里，然后在容器和主机中分别设置几条路由，来完成网络的互联。
calico实现中几个特点：
1、宿主机上所有的calixxx设备的MAC地址都是“ee:ee:ee:ee:ee:ee”，而且开启了arp proxy功能。
2、pod内的路由表是固定的。所有的pod中默认网关都是169.254.1.1，且不属于任何一个设备，但是可以响应arp请求。该请求是由pod内eth0的对端calixxx设备响应的，响应的MAC地址是calixxx的Mac地址。
[root@dev-k8s-node1 ~]# docker exec -it 30a94a4e19c0 ip route default via 169.254.1.1 dev eth0 169.254.1.1 dev eth0 scope link [root@dev-k8s-node1 ~]# docker exec -it 30a94a4e19c0 ip neigh 169.254.1.1 dev eth0 lladdr ee:ee:ee:ee:ee:ee ref 1 used 0/0/0 probes 4 REACHABLE 也就是说，通过默认网关，pod内的请求会发送到其对端的calixxx设备上。之后的网络报文流动，是由宿主机的路由表决定的。
总结：
Calico 通过一个巧妙的方法将 workload 的所有流量引导到一个特殊的网关 169.254.1.1，从而引流到主机的 calixxx 网络设备上，最终将二三层流量全部转换成三层流量来转发。 在主机上通过开启代理 ARP 功能来实现 ARP 应答，使得 ARP 广播被抑制在主机上，抑制了广播风暴，也不会有 ARP 表膨胀的问题。 $ ip link add veth0 type veth peer name eth0 $ ip netns add ns0 #pod内路由设置、ip设置 $ ip link set eth0 netns ns0 $ ip netns exec ns0 ip a add 10.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/3-Calico-IPIP%E6%A8%A1%E5%BC%8F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/3-Calico-IPIP%E6%A8%A1%E5%BC%8F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</guid><description>转载声明：
https://blog.csdn.net/u010771890/article/details/103224004
IPIP模式简介 Calico中的IP Pool可以使用两种模式：BGP或者IPIP。本文使用的是IPIP模式，是一种将各Node的路由之间做一个tunnel，再把网络连接起来的模式：
从字面上说，就是将一个IP数据包套在另一个IP包里，使用到了Linux提供的隧道技术。可以理解为一个基于IP层的网桥，将两个本不通的网络通过点对点连接起来。
IPIP是一种将各Node的路由之间做一个tunnel，再把两个网络连接起来的模式，启用IPIP模式时，Calico将在各Node上创建一个名为&amp;quot;tunl0&amp;quot;的虚拟网络接口。
K8s-Calico-IPIP网络实战分析 下面我们就进行基于Calico-IPIP模式下的K8s容器互联网络分析。
实验准备 准备了1个master 2个slaver的K8s集群，设置为Calico-IPIP网络。每个slaver内（node1，node2）分别部署了一个Pod容器，结构示意图如下：
网络结构解析 pod网络 首先通过指令kubectl exec -it pod1 /bin/bash进入pod1容器中，再使用指令 ip addr 查看pod1内的网络设备。
ip addr 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 4: eth0@if26: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1440 qdisc noqueue state UP group default link/ether ce:83:2b:89:af:9e brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.100.15.150/32 scope global eth0 valid_lft forever preferred_lft forever 可以看到，pod只有普通的loopback和eth0。</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/4-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E8%BF%90%E7%BB%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/4-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E8%BF%90%E7%BB%B4/</guid><description>转载：https://www.bladewan.com/2020/11/18/calico_ops/
版本 更改说明 更新人 日期 0.1 创建文档 我爱西红柿 202006 0.2 添加其他方式部署calico 我爱西红柿 202106 0.3 更新切换BGP方式和Namespace固定ip 我爱西红柿 20220323 适用范围 本文档测试范围
软件 版本 Kubernetes v1.14.x,v1.15.x,v1.16.x calico v3.13.4 概述 Calico是一种开源网络和网络安全解决方案，适用于容器，虚拟机和基于主机的本机工作负载。Calico支持广泛的平台，包括Kubernetes，docker，OpenStack和裸机服务。Calico后端支持多种网络模式。
BGP模式：将节点做为虚拟路由器通过BGP路由协议来实现集群内容器之间的网络访问。 IPIP模式：在原有IP报文中封装一个新的IP报文，新的IP报文中将源地址IP和目的地址IP都修改为对端宿主机IP。 cross-subnet：Calico-ipip模式和calico-bgp模式都有对应的局限性，对于一些主机跨子网而又无法使网络设备使用BGP的场景可以使用cross-subnet模式，实现同子网机器使用calico-BGP模式，跨子网机器使用calico-ipip模式。 calico切换BGP模式 部署完成后默认使用calico-ipip的模式，通过在节点的路由即可得知，通往其他节点路由通过tunl0网卡出去
修改为BGP网络模式，在system项目中修改calico-node daemonset
修改CALICO_IPV4POOL_IPIP改为off，添加新环境变量FELIX_IPINIPENABLED为false
修改完成后对节点进行重启，等待恢复后查看主机路由，与ipip最大区别在于去往其他节点的路由，由Tunnel0走向网络网卡。
calico切换cross-subnet模式 Calico-ipip模式和calico-bgp模式都有对应的局限性，对于一些主机跨子网而又无法使网络设备使用BGP的场景可以使用cross-subnet模式，实现同子网机器使用calico-BGP模式，跨子网机器使用calico-ipip模式。
部署集群网络选择calico网络插件 默认部署出来是calico的ip-in-ip的模式 查看宿主机网卡，会发现多了个tunl0网卡，这个是建立ip隧道的网卡
去其他主机的路由都是走tunl0网卡出去
切换到cross-subnet模式
kubectl edit ipPool/default-ipv4-ippool 将ipipMode改为crossSubnet
在UI将calico-node的POD删了重建
重启检查calico网络 可以看见同子网的主机出口走的是bgp，不同子网主机走的是tunl0网卡走ipip模式 验证 创建应用测试跨主机网络，在不同主机上互相ping测试，看看跨主机网络是否正常。
配置Route reflector 安装calicoctl 安装方式
Single host上面binary安装 Single host上面continer安装 作为k8s pod运行 实际经验：
Binary方式在集群里面的一台worker节点安装（比如RR）
calicoctl会检测bird/felix的运行状态
在非calico node节点运行只能使用部分命令，不能运行calico node相关命令
通过配置calicoctl来对calico进行控制，通常情况下建议将
curl -O -L https://github.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/calicoctl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/k8s%E7%BD%91%E7%BB%9C/%E8%AE%BF%E9%97%AEPod-Calico%E7%BD%91%E7%BB%9C/calicoctl/</guid><description>calicoctl get workloadendpoint # calicoctl get wep</description></item></channel></rss>