<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Helm on ljzsdut</title><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/</link><description>Recent content in Helm on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/00-Helm2%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/00-Helm2%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</guid><description>helm简介 类似于软件包安装使用的yum。helm是提供资源的配置清单文件集合的仓库。
核心术语：
Chart：一个helm程序包； Repository：Charts仓库，https/http服务器； Release：特定的Chart部署于目标集群上的一个实例； Chart -&amp;gt; Config -&amp;gt; Release
程序架构：
helm：客户端，管理本地的Chart仓库，管理Chart, 与Tiller服务器交互，发送Chart，实现实例安装、查询、卸载等操作 Tiller：服务端，接收helm发来的Charts与Config，合并生成relase并进行部署； 安装Helm v2服务端Tiller： 到github的release中下载编译好的helm二进制包:https://github.com/helm/helm/releases 使用helm init安装Tiller，helm init时使用k8s的config文件作为配置文件连接apiserver：将~/.kube/config拷贝到helm所在主机的~/.kube/config，也可以使用&amp;ndash;kubeconfig参数指定config文件的位置。此时helm便可以工作了 如果k8s集群启用了rbac，Tiller服务器需要能获取到整个集群的管理权限来完成k8s集群的应用安装、卸载等管理操作，需要先创建基于rbac的ServiceAccount（名称为tiller）： apiVersion: v1 kind: ServiceAccount metadata: name: tiller namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: tiller roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: tiller namespace: kube-system 初始化：在k8s集群上创建Tiller： helm init使用参数：
安装指定Tiller的image：--tiller-image 指定Tiller安装在哪一个Kubernetes集群：--kube-context 指定Tiller安装在哪个namespace：--tiller-namespace ,默认为kube-system [root@physerver src]# helm init --service-account tiller Creating /root/.helm Creating /root/.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/00-Helm3%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/00-Helm3%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</guid><description>安装Helm v3: 在 Helm 3 中移除了 Tiller, 版本相关的数据直接存储在了 Kubernetes 中。安装v3版本的helm，只需要安装helm二进制客户端即可。helm客户端和kubelet一样，使用kubeconfig配置文件连接k8s集群，具有和kubelet一样的RBAC权限。
helm发行版地址：https://github.com/helm/helm/releases
helmhub地址：https://hub.helm.sh/
对于mac，可以使用brew insgtall helm进行安装。
添加stable仓库：helm repo add stable https://kubernetes-charts.storage.googleapis.com/ stable仓库源码地址：https://github.com/helm/charts
自动补全：source &amp;lt;(helm completion zsh)，可以写入到/etc/profile中
helm三大概念 Chart：chart是k8s的安装包。它包含在Kubernetes集群中运行应用程序、工具或服务所需的所有资源定义。可以将其视为类似于Homebrew的formula，Apt dpkg或Yum RPM文件。 Repository：repository是可以收集和共享chart的地方。 类似于rpm包的yum仓库。 Release：release是在Kubernetes集群中运行的chart的实例。一个chart通常可以多次安装到同一群集中。并且每次安装时，都会创建一个新的release。比如一个MySQL的release。如果要在群集中运行两个数据库，则可以两次安装该chart。每一次安装都有其自己的release，而每个release都有自己的release名称。 三者关系：
Helm将chart安装到Kubernetes中，为每次安装创建一个release。要查找新的chart，可以搜索Helm的repository。
helm使用 helm查看帮助 helm help helm COMMAND -h helm search：搜索chart helm search hub KEYWORD：从helm hub上搜索。 helm search repo KEYWORD：从本地helm仓库搜索。helm搜索通过helm repo add添加的本地仓库。该搜索是通过本地数据完成的，不需要公共网络连接。 helm search使用模糊字符串匹配算法，因此您可以键入部分单词或短语：
helm search hub wordpress helm search repo stable/mysql helm install ：安装包 默认配置安装 helm install [NAME] [CHART] [flags] ，一般要指定release的名称和chart的名称。</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/01-%E8%87%AA%E5%AE%9A%E4%B9%89chart%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/01-%E8%87%AA%E5%AE%9A%E4%B9%89chart%E5%85%A5%E9%97%A8/</guid><description>预备知识 学习该内容之前，请确保您已经了解helm的基本使用。
创建chart包 我们可以使用helm create创建一个chart目录模板，在此目录模板的基础上对chart进行自定义修改。
➜ ~ helm create mychart Creating mychart chart目录结构 通过上面的命令，创建了一个名称为mychart的chart包，我们查看chart包的文件结构如下：
➜ ~ tree mychart mychart ├── Chart.yaml ├── charts ├── templates │ ├── NOTES.txt │ ├── _helpers.tpl │ ├── deployment.yaml │ ├── hpa.yaml │ ├── ingress.yaml │ ├── service.yaml │ ├── serviceaccount.yaml │ └── tests │ └── test-connection.yaml └── values.yaml 3 directories, 10 files 以上目录结构就是一个chart包的基本结构，我们先认识一下各个目录、文件的主要作用。
Chart.yaml： chart包的metedata信息(元数据)。例如chart的名称、版本、描述信息。通常结合requirements.yaml文件一起使用 charts：主要存放当前chart的子chart包。子chart是当前chart所依赖的chart。 templates ：模板文件 NOTES.txt：在执行helm install时显示的提示信息。 _helpers.tpl：该文件以.tpl后缀结尾，文件名可以任意。作用是放置模板的公共模块(命名模板/子模板)，可以在整个chart的其他地方重复引用。 *.yaml ：k8s的资源配置文件，使用go-template编写。 values.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/02-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8CValue%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/02-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8CValue%E5%AF%B9%E8%B1%A1/</guid><description>对模板进行debug 调试模板可能会很棘手，因为渲染的模板已发送到Kubernetes apiserver，该服务器可能会出于格式化以外的其他原因而拒绝YAML文件。可以通过如下方式进行模板debug：
helm lint验证chart是否遵循最佳实践。 helm install --dry-run --debug or helm template --debug: 让服务器渲染模板，并返回资源清单。 helm get manifest: 查看已经安装在k8s中的资源清单。 helm template CHART：进行go-template渲染，注意该操作只能检查go-template渲染的语法。渲染成功并不一定能满足k8s的接口规范。 添加模板 总结：模板指令要写在{{ }}中
我们可以看到上⾯定义的 ConfigMap 名字是固定的，但往往这并不是⼀种很好的做法，我们可以通过插入 release 的名称来生成资源的名称，比如这里 ConfigMap 的名称我们希望是：values-release-configmap，这就需要用到 Chart 的模板定义方法了。Helm Chart 模板使用的是 Go 语⾔模板编写而成，并添加了 Sprig 库中的50多个附件模板函数以及⼀些其他特殊的函数。
注：需要注意的是 kubernetes 资源对象的 labels 和 name 定义被限制 63个字符，所以需要注意名称的定义。
现在我们来重新定义上面的 configmap.yaml 文件：
➜ ~ vim mychart/templates/configmap.yaml ➜ ~ cat mychart/templates/configmap.yaml apiVersion: v1 kind: ConfigMap metadata: name: {{ .Release.Name }}-configmap data: myvalue: &amp;#34;Hello World&amp;#34; 我们将名称替换成了 {{ .</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/03-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%A1%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/03-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%A1%E9%81%93/</guid><description>今天我们来学习Helm3模板中的模板函数与管道。虽然我们通过Values把信息注入到了模板当中，但是这些信息都是直接传入模板引擎中进行渲染的，有的时候我们想要转换⼀下这些数据才进行渲染，这就需要使用到 Go 模板语⾔中的⼀些其他用法。
模板函数 比如我们需要从 .Values中读取的值变成字符串的时候就可以通过调用&amp;quot;quote&amp;quot;模板函数来实现。
模板函数遵循调用的语法为：functionName arg1 arg2。
在下面的模板文件中， quote .Values.course.k8s 调用 quote 函数并将后面的值作为⼀个参数传递给它。
➜ ~ vim mychart/templates/configmap.yaml ➜ ~ cat mychart/templates/configmap.yaml apiVersion: v1 kind: ConfigMap metadata: name: {{ .Release.Name }}-configmap data: myvalue: &amp;#34;Hello World&amp;#34; k8s: {{ quote .Values.course.k8s }} python: {{ .Values.course.python }} 最终被渲染下面的内容(templates/configmap.yaml)：
➜ ~ helm install mychart mychart/ --dry-run NAME: mychart LAST DEPLOYED: Tue Feb 23 14:37:05 2021 NAMESPACE: default STATUS: pending-install REVISION: 1 TEST SUITE: None HOOKS: MANIFEST: --- # Source: mychart/templates/configmap.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/04-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/04-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8F%98%E9%87%8F/</guid><description>模板函数和管道是通过转换信息并将其插入到 YAML 文件中的强大方法。但有时候需要添加⼀些比插入字符串更复杂的模板逻辑。这就需要使用到模板语⾔中提供的控制结构了。
控制流程为我们提供了控制模板生成流程的⼀种能力，Helm 的模板语⾔提供了以下几种流程控制：
if/else 条件块 with 指定范围 range 循环块 除此之外，它还提供了⼀些声明和使用命名模板段的操作：
define 在模板中声明⼀个新的命名模板 template 导入⼀个命名模板 block 声明了⼀种特殊的可填写的模板区域 关于 命名模板 的相关知识点，我们会在后⾯文章中详细讲解，这里我们暂时介绍 if/else 、 with 、 range 这3中控制流程的用法。更多的内容可以去Helm3官方文档中详细查看：点击查看
if/else条件 if/else 块是用于在模板中有条件地包含文本块的方法，条件块的基本结构如下：
{{ if PIPELINE }} # Do something {{ else if OTHER PIPELINE }} # Do something else {{ else }} # Default case {{ end }} 当然要使用条件块就得判断条件是否为真，如果值为下⾯的几种情况，则管道的结果为 false：
⼀个布尔类型的 假 ⼀个数字 零 ⼀个 空 的字符串 ⼀个 nil （空或 null ） ⼀个空的集合（ map 、 slice 、 tuple 、 dict 、 array ） 除了上⾯的这些情况外，其他所有条件都为 真 。</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/05-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/05-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF/</guid><description>前面我们学习了 Helm 模板中的⼀些常用方法，但都是操作的⼀个模板文件，在实际的应用中，很多都是相对比较复杂的，往往会超过⼀个模板，如果有多个应用模板，我们应该如何进行处理呢？这就需要用到新的概念：命名模板。
命名模板我们也可以称为子模板，是限定在⼀个文件内部的模板，然后给⼀个名称。在使用命名模板的时候有⼀个需要特别注意的是：模板名称是全局的，如果我们声明了两个相同名称的模板，最后加载的⼀个模板会覆盖掉另外的模板，由于子 chart 中的模板也是和顶层的模板⼀起编译的，所以在命名的时候⼀定要注意，不能重名了。为了避免重名，有个通用的约定就是为每个定义的模板添加上 chart 名称： {{define &amp;quot;mychart.labels&amp;quot; }} ， define 关键字就是用来声明命名模板的，加上 chart 名称就可以避免不同chart 间的模板出现冲突的情况。
声明和使用命名模板 使用 define 关键字就可以允许我们在模板文件内部创建⼀个命名模板，它的语法格式如下：
{{ define &amp;#34;ChartName.TplName&amp;#34; }} # 模板内容区域 {{ end }} 比如，现在我们可以定义⼀个模板来封装⼀个 label 标签：
{{- define &amp;#34;mychart.labels&amp;#34; }} labels: from: helm date: {{ now | htmlDate }} {{- end }} 然后我们可以将该模板嵌⼊到现有的 ConfigMap 中，然后使⽤ template 关键字在需要的地⽅包含进 来即可：
{{- define &amp;#34;mychart.labels&amp;#34; }} labels: from: helm date: {{ now | htmlDate }} {{- end }} apiVersion: v1 kind: ConfigMap metadata: name: {{ .</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/06-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/06-helm%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>上节课我们学习了命名模板的使用，命名模板是 Helm 模板中非常重要的一个功能，在我们实际开发 Helm Chart 包的时候非常有用，到这里我们基本上就把 Helm 模板中经常使用到的一些知识点和大家介绍完了。但是仍然还是有一些在开发中值得我们注意的一些知识点，比如 NOTES.txt 文件的使用、子 Chart 的使用、全局值的使用，这节课我们就来和大家一起了解下这些知识点。
NOTES.txt 文件 我们前面在使用 helm install 命令的时候，Helm 都会为我们打印出一大堆介绍信息，这样当别的用户在使用我们的 chart 包的时候就可以根据这些注释信息快速了解我们的 chart 包的使用方法，这些信息就是编写在 NOTES.txt 文件之中的，这个文件是纯文本的，但是它和其他模板一样，具有所有可用的普通模板函数和对象。
现在我们在前面的示例中 templates 目录下面创建一个 NOTES.txt 文件：
Thank you for installing {{ .Chart.Name }}. Your release is named {{ .Release.Name }}. To learn more about the release, try: $ helm status {{ .Release.Name }} $ helm get {{ .Release.Name }} 我们可以看到我们在 NOTES.txt 文件中也使用 Chart 和 Release 对象，现在我们在 mychart 包根目录下面执行安装命令查看是否能够得到上面的注释信息：</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/07-helm%E4%B9%8Bhooks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/07-helm%E4%B9%8Bhooks/</guid><description>和 Kubernetes 里面的容器一样，Helm 也提供了 Hook 的机制，允许 chart 开发人员在 release 的生命周期中的某些节点来进行干预，比如我们可以利用 Hooks 来做下面的这些事情：
在加载任何其他 chart 之前，在安装过程中加载 ConfigMap 或 Secret 在安装新 chart 之前执行作业以备份数据库，然后在升级后执行第二个作业以恢复数据 在删除 release 之前运行作业，以便在删除 release 之前优雅地停止服务 Hook一般在Job中定义，完成某些任务。
值得注意的是 Hooks 和普通模板使用一样工作的工作方式，但是它们具有特殊的注解，可以使 Helm 以不同的方式使用它们。
Hook 在资源清单中的 metadata 部分用 annotations 的方式进行声明：
apiVersion: ... kind: .... metadata: annotations: &amp;#34;helm.sh/hook&amp;#34;: &amp;#34;pre-install&amp;#34; # ... 接下来我们就来和大家介绍下 Helm Hooks 的一些基本使用方法。
Hooks helm安装chart的生命周期：渲染模板&amp;ndash;&amp;gt;安装模板&amp;ndash;&amp;gt;删除/更新/回滚模板
在 Helm 中定义了如下一些可供我们使用的 Hooks：
预安装pre-install：在模板渲染后，kubernetes 创建任何资源之前执行 安装后post-install：在所有 kubernetes 资源安装到集群后执行 预删除pre-delete：在从 kubernetes 删除任何资源之前执行删除请求 删除后post-delete：删除所有 release 的资源后执行 升级前pre-upgrade：在模板渲染后，但在任何资源升级之前执行 升级后post-upgrade：在所有资源升级后执行 预回滚pre-rollback：在模板渲染后，在任何资源回滚之前执行 回滚后post-rollback：在修改所有资源后执行回滚请求 crd-install：在运行其他检查之前添加 CRD 资源，只能用于 chart 中其他的资源清单定义的 CRD 资源。 生命周期 Hooks 允许开发人员在 release 的生命周期中的一些关键节点执行一些钩子函数，我们正常安装一个 chart 包的时候的生命周期如下所示：</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/08-%E5%A6%82%E4%BD%95%E5%9C%A8HelmChart%E4%B8%AD%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%90%8CKubernetes%E7%89%88%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/08-%E5%A6%82%E4%BD%95%E5%9C%A8HelmChart%E4%B8%AD%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%90%8CKubernetes%E7%89%88%E6%9C%AC/</guid><description>随着 Kubernetes 的版本不断迭代发布，很多 Helm Chart 包压根跟不上更新的进度，导致在使用较新版本的 Kubernetes 的时候很多 Helm Chart 包不兼容，所以我们在开发 Helm Chart 包的时候有必要考虑到对不同版本的 Kubernetes 进行兼容。
要实现对不同版本的兼容核心就是利用 Helm Chart 模板提供的内置对象 Capabilities，该对象提供了关于 Kubernetes 集群支持功能的信息，包括如下特性：
Capabilities.APIVersions 获取集群版本集合 Capabilities.APIVersions.Has $version 判断集群中的某个版本 (e.g., batch/v1) 或是资源 (e.g., apps/v1/Deployment) 是否可用 Capabilities.KubeVersion 和 Capabilities.KubeVersion.Version 可以获取 Kubernetes 版本号 Capabilities.KubeVersion.Major 获取 Kubernetes 的主版本 Capabilities.KubeVersion.Minor 获取 Kubernetes 的次版本 Capabilities.HelmVersion 包含 Helm 版本详细信息的对象，和 helm version 的输出一致 Capabilities.HelmVersion.Version 是当前 Helm 版本的语义格式 Capabilities.HelmVersion.GitCommit Helm 的 git sha1 值 Capabilities.HelmVersion.GitTreeState 是 Helm git 树的状态 Capabilities.</description></item><item><title/><link>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/09-Helm-Charts-%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E4%BA%91%E5%8E%9F%E7%94%9F/helm/09-Helm-Charts-%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B/</guid><description>Helm 的使用是比较简单的，但是要让我们自己开发一个 Chart 包还是有不小难度的，主要还是 go template 的语法规则不够人性化，这里我们用一个完整的实例来演示下如何开发一个 Helm Chart 包。
应用 我们这里以 Ghost 博客应用为例来演示如何开发一个完整的 Helm Chart 包，Ghost 是基于 Node.js 的开源博客平台。在开发 Helm Chart 包之前我们最需要做的的就是要知道我们自己的应用应该如何使用、如何部署，不然是不可能编写出对应的 Chart 包的。
启动 Ghost 最简单的方式是直接使用镜像启动：
➜ docker run -d --name my-ghost -p 2368:2368 ghost 然后我们就可以通过 http://localhost:2368 访问 Ghost 博客了。如果我们想要在 Kubernetes 集群中部署两个副本的 Ghost，可以直接应用下面的资源清单文件即可：
# ghost/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: ghost spec: selector: matchLabels: app: ghost-app replicas: 2 template: metadata: labels: app: ghost-app spec: containers: - name: ghost-app image: ghost ports: - containerPort: 2368 --- # ghost/service.</description></item></channel></rss>