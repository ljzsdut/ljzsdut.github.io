<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ljzsdut</title><link>https://note.ljzsdut.com/Git/</link><description>Recent content on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/Git/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/Git/01-object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/Git/01-object/</guid><description>git基本3个空间 git init发生了什么？  [ Mac-mini:/Users/lijuzhang/test ] ➜ mkdir git-demo [ Mac-mini:/Users/lijuzhang/test ] ➜ cd git-demo [ locolhost:/Users/lijuzhang/test/git-demo ] ➜ git init . Initialized empty Git repository in /Users/lijuzhang/test/git-demo/.git/ [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ ls -a . .. .git [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ ls -la .git total 24 drwxr-xr-x 9 lijuzhang staff 288 4 9 11:19 . drwxr-xr-x 3 lijuzhang staff 96 4 9 11:19 .. -rw-r--r-- 1 lijuzhang staff 23 4 9 11:19 HEAD -rw-r--r-- 1 lijuzhang staff 137 4 9 11:19 config -rw-r--r-- 1 lijuzhang staff 73 4 9 11:19 description drwxr-xr-x 13 lijuzhang staff 416 4 9 11:19 hooks drwxr-xr-x 3 lijuzhang staff 96 4 9 11:19 info drwxr-xr-x 4 lijuzhang staff 128 4 9 11:19 objects drwxr-xr-x 4 lijuzhang staff 128 4 9 11:19 refs 我们发现，init后，会在当前目录下生成一个.</description></item><item><title/><link>https://note.ljzsdut.com/Git/02-branch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/Git/02-branch/</guid><description>什么是branch？ 分支是一个有名字的指针，该指针指向某个commit。
什么是HEAD？ HEAD是一个特殊的指针，该指针总是指向当前分支的最新的commit。
[ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ cat .git/HEAD ref: refs/heads/master [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ cat .git/refs/heads/master 916cedf33208cc0031d838fc942481ac11fd432b [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ git cat-file -t 916ced commit [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ git cat-file -p 916ced tree 6f1c48e7934b61a9eaecea3fe3c8832073ea0a7a parent 61b3faa3de3bf8d11d6d4d811833cbf92151c1e6 author ljzsdut &amp;lt;lijuzhang@inspur.com&amp;gt; 1649489508 +0800 committer ljzsdut &amp;lt;lijuzhang@inspur.com&amp;gt; 1649489508 +0800 3rd commit 创建分支 git brach #查看 git branch &amp;lt;branch_name&amp;gt; #创建 git branch -d|-D &amp;lt;branch_name&amp;gt; #删除，注意不能删除当前分支 git checkout &amp;lt;branch_name&amp;gt; #切换 git checkout -b &amp;lt;branch_name&amp;gt; #创建 [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ git branch * master (END) [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ git branch dev [ Mac-mini:/Users/lijuzhang/test/git-demo ] git:(master) ➜ tree .</description></item><item><title/><link>https://note.ljzsdut.com/Git/03-Git%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA%E8%AE%A9%E6%88%91%E4%BB%AC%E5%AD%A6%E4%B9%A0Git%E4%BA%8B%E5%8D%8A%E5%8A%9F%E5%80%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/Git/03-Git%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%A8%E7%94%BB%E5%B1%95%E7%A4%BA%E8%AE%A9%E6%88%91%E4%BB%AC%E5%AD%A6%E4%B9%A0Git%E4%BA%8B%E5%8D%8A%E5%8A%9F%E5%80%8D/</guid><description>转载：https://zhuanlan.zhihu.com/p/190303151
原文地址： CS Visualized: Useful Git Commands 原文作者：Lydia Hallie 尽管Git是一个非常强力的工具，但如果我说这也可能是一场噩梦 ，我想大多数人也会同意。在使用Git的时候，我发现在我的大脑中想象发生了什么是非常有用的：在我执行特定命令的时候，分支之间是如何相互影响的，以及它会如何影响历史日志？当我在master分支做了硬重置(hard reset),强制推送(force push)到master分支并且rimraf .git目录之后，我的同事为什么会哭？
我认为为最常用和最有用的命令创建一些可视化的图例将会成为完美的使用示例！ 我涉及到的许多命令拥有可选的参数，您可以使用这些参数来更改命令的行为。在示例中，我将会涉及没有添加(太多)配置项命令的默认行为！
Merging(合并) 拥有多个分支是极其方便的，他可以使新的更新彼此分离，也可以确保您不会意外的推送未经批准或破坏性更改的代码到生产环境。一旦更改被批准，我们便想在生产环境获得这些更改。
从一个分支获得另一个分支更改的一种方式是执行git merge命令。Git可以执行俩种类型的合并：
fast-forward non-fast-forward 现在说这些可能没有太大意义，我们先看一下它们之间的区别。
Fast-forward(--ff) 与我们正在合并的分支相比，当当前分支没有额外提交的时候，会发生fast-forward-merge。Git是懒惰的，它会首先尝试最简单的选项：fast-forward!这种类型的合并不会创建一个新的提交，而是在当前分支上合并我们正在合并分支上的提交 。
完美！我们现在在master分支上可以找到所有在dev分支上做出的更改。那么，non-fast-forward又是什么意思呢？
No-fast-forward(--no-ff) 相比于您想要合并的分支，当前分支没有任何额外的提交是极好的，但不幸的是那是很罕见的情况！如果在当前分支上提交的更改在我们想要合并的分支上不存在，Git将会执行一次no-fast-forward合并。
随着一次no-fast-forward合并，Git在活动分支(master)上创建一个新的合并提交。该提交的父提交同时指向活动分支和我们想要合并的分支(dev)。
没什么大不了的，一次完美的合并！ master分支现在包含了所有我们在dev分支上做出的所有更改。
Merge Conflicts(合并冲突) 尽管Git擅长如何去合并分支以及向文件中添加更改，但是它不能总是依靠它自己来做出所有的决定 。当我们尝试合并的俩个分支在同一个文件的同一行上有不同的更改，或者如果一个分支删除了一个在另一个分支被编辑过的文件等情况发生的时候，Git将不能自己决定该如何合并代码。
在这种情况下，Git将会询问您来帮助决定我们想要保留俩个选项中的哪一个。比如说在俩个分支上，我们都编辑了README.MD中的第一行。
如果您想把dev合并到master，这将会导致合并冲突：您希望标题是Hello!还是Hey!?
在尝试合并分支的时候，Git将会为您显示冲突发生的位置。我们可以手动移除我们不想保留的更改，保存剩余的更改，再次添加文件到暂存区，然后提交所有更改的文件 。
好极了！尽管解决冲突十分烦人，但是它完全有意义：Git不应该只是假设我们想要保留哪些更改。
Rebasing 我们刚刚已经看过如何通过执行一个git merge命令，将来自于一个分支的更改应用到另一个分支。从一个分支添加更改到另一个分支的另一个方法是执行git rebase命令。
git rebase会从当前分支拷贝提交，并且将这些拷贝的提交放到指定分支的顶部。
完美，我们现在在dev分支上可以找到所有在master分支上做出的更改！
rebase和merge命令一个最大的不同是：Git不会尝试去找出哪些文件要保留，哪些文件不需要保留。我们正在rebase的分支总是拥有我们想要保留的最新更改！这种方式在之后合并过程中不会遇到任何冲突，并且可以保持一个很好的直线Git历史记录。
“ 译者注：这里指的不会遇到任何冲突的情况如下(还是以上图为例)：
dev$ git rebase master 将dev的提交拷贝一份复制到master的顶部 dev$ git checkout master master$ git merge dev 此时master相当于没有做任何额外的提交，会进行fast-forward-merge，保持直线提交记录 这个例子展示了在master分支上进行rebase。然而在更大的项目中，通常不希望这样做。由于拷贝的提交创建了新的哈希值，所以git rebase改变了项目的历史记录。
无论何时您在一个特性分支上工作，并且master分支已经被更新，rebase都是一种很好的做法。您可以在自己的分支上获取到所有的更新，这将阻止未来的合并冲突！
交互式的 rebase 在rebase提交之前，我们可以编辑它们！ 我们可以使用一个交互式的rebase来做这件事。交互式rebase对于您当前正在工作的分支以及想要修改的某些提交也是很有用处的。</description></item><item><title/><link>https://note.ljzsdut.com/Git/04-git%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/Git/04-git%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/</guid><description> git配置文件概述 常用配置 使用git status中文文件显示乱码
git config --global core.quotepath false 设置全局的gitignore文件
git config --global core.excludesfile ~/.gitignore 记住密码，避免每次commit都需要输入密码
root@mgt01:/opt/update_pub# git config --global credential.helper store root@mgt01:/opt/update_pub# git config --global --list credential.helper=store</description></item><item><title/><link>https://note.ljzsdut.com/Git/05-git-reset-softhardmixed%E4%B9%8B%E5%8C%BA%E5%88%AB%E6%B7%B1%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/Git/05-git-reset-softhardmixed%E4%B9%8B%E5%8C%BA%E5%88%AB%E6%B7%B1%E8%A7%A3/</guid><description>git reset soft,hard,mixed之区别深解 GIT reset命令，似乎让人很迷惑，以至于误解，误用。但是事实上不应该如此难以理解，只要你理解到这个命令究竟在干什么。
首先我们来看几个术语
HEAD 这是当前分支版本顶端的别名，也就是在当前分支你最近的一个提交(当前分支的顶端)。
（HEAD/branch本身就是一个指向一个commit的指针）
Index index也被称为staging area，是指一整套即将被下一个提交的文件集合。他也是将成为HEAD的父亲的那个commit
staging area:部队从一个战场转往另一个战场的集结地
Working Copy working copy代表你正在工作的那个文件集
Flow 当你第一次checkout一个分支，HEAD就指向当前分支的最近一个commit。在HEAD中的文件集（实际上他们从技术上不是文件，他们是blobs（一团），但是为了讨论的方便我们就简化认为他们就是一些文件）和在index中的文件集是相同的，在working copy的文件集和HEAD,INDEX中的文件集是完全相同的。所有三者(HEAD,INDEX(STAGING),WORKING COPY)都是相同的状态，GIT很happy。
当你对一个文件执行一次修改，Git感知到了这个修改，并且说：“嘿，文件已经变更了！你的working copy不再和index,head相同！”，随后GIT标记这个文件是修改过的。
然后，当你执行一个git add,它就stages the file in the index，并且GIT说：“嘿，OK，现在你的working copy和index区是相同的，但是他们和HEAD区是不同的！”
当你执行一个git commit,GIT就创建一个新的commit，随后HEAD就指向这个新的commit，而index,working copy的状态和HEAD就又完全匹配相同了，GIT又一次HAPPY了。
reset&amp;amp;checkout 下面这一段是另外一个牛人的解释：
总的来说，git reset命令是用来将当前branch重置到另外一个commit的，而这个动作可能会同样影响index以及work tree。比如如果你的master branch（当前checked out）是下面这个样子:
- A - B - C (HEAD, master) HEAD和master branch tip是在一起的，而你希望将master指向到B，而不是C，那么你执行
git reset B以便移动master branch到B那个commit：
- A - B (HEAD, master) # - C is still here, but there&amp;#39;s no branch pointing to it anymore HEAD, master同时移动，仍然在一起。</description></item><item><title/><link>https://note.ljzsdut.com/Git/06-git-stash%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/Git/06-git-stash%E8%AF%A6%E8%A7%A3/</guid><description>git stash详解 应用场景： 1 当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。 2 由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。 总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。
命令详解： 1 git stash 能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。
$ git status On branch master Changes not staged for commit: (use &amp;#34;git add &amp;lt;file&amp;gt;...&amp;#34; to update what will be committed) (use &amp;#34;git checkout -- &amp;lt;file&amp;gt;...&amp;#34; to discard changes in working directory) modified: src/main/java/com/wy/CacheTest.java modified: src/main/java/com/wy/StringTest.java no changes added to commit (use &amp;#34;git add&amp;#34; and/or &amp;#34;git commit -a&amp;#34;) $ git stash Saved working directory and index state WIP on master: b2f489c second $ git status On branch master nothing to commit, working tree clean1234567891011121314151617 2 git stash save 作用等同于git stash，区别是可以加一些注释，如下： git stash的效果：</description></item><item><title/><link>https://note.ljzsdut.com/Git/07-lazygit%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/Git/07-lazygit%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</guid><description> https://blog.csdn.net/cumo3681/article/details/107407815 切换面板上的tag [或]（中括号）
Local Branches n ：创建新的本地分支 空格 ：切换至选中分支（git checkout ${BRANCH_NAME}） D ：删除选中分支 p ：pull P ：push M：把选中的分支合并到当前分支 Commits 回车：查看commit更改信息 逗号、句号：翻页 &amp;lt;&amp;gt;：top、tail / : 搜索 r/R ：重新命名本地分支名 Stash s ：stash 隐藏； 在stash区，g还原至files区，并删除stash条目(git stash pop) 在stash区，&amp;ldquo;空格&amp;rdquo;：恢复，但不删除stash条目(git stash apply) 在stash区，d：删除stash条目(git stash drop NAME)</description></item></channel></rss>