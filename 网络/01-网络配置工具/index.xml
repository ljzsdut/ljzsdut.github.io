<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ljzsdut</title><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/</link><description>Recent content on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/02-nmcli%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/02-nmcli%E5%91%BD%E4%BB%A4/</guid><description>设置ip和用户名：
setenforce 0 hostnamectl set-hostname node03 &amp;amp;&amp;amp; exec bash nmcli connection modify eth0 ipv4.addr &amp;#34;192.168.5.235/24&amp;#34; nmcli connection modify eth0 ipv4.gateway &amp;#34;192.168.5.1&amp;#34; nmcli connection modify eth0 ipv4.dns &amp;#34;192.168.5.1&amp;#34; nmcli connection modify eth0 ipv4.method manual nmcli connection modify eth0 autoconnect yes nmcli con up eth0 或者 nmcli dev reapply eth0 或者 nmcli dev connect eth0 或者 systemctl restart network setenforce 0
HOST_NAME=$(hostname -I|awk -F. &amp;#39;{printf &amp;#34;vm-%s-%s&amp;#34;,$3,$4}&amp;#39;)
hostnamectl set-hostname ${HOST_NAME} &amp;amp;&amp;amp; exec bash [TOC]</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/21-ip-%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95%E5%BD%92%E7%BA%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/21-ip-%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95%E5%BD%92%E7%BA%B3/</guid><description>[TOC]
解读 ip 命令展示的网络连接信息 $ ip a 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s25: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:1e:4f:c8:43:fc brd ff:ff:ff:ff:ff:ff inet 192.168.0.24/24 brd 192.168.0.255 scope global dynamic enp0s25 valid_lft 57295sec preferred_lft 57295sec inet6 fe80::2c8e:1de0:a862:14fd/64 scope link valid_lft forever preferred_lft forever 为什么是 enp0s25 而不是 eth0 如果你想知道为什么它在这个系统上被称为 enp0s25，而不是可能更熟悉的 eth0，那我们可以稍微解释一下。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/22-ip%E5%91%BD%E4%BB%A4%E4%B9%8BLinux%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1ip-rule-ip-route/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/22-ip%E5%91%BD%E4%BB%A4%E4%B9%8BLinux%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1ip-rule-ip-route/</guid><description>转载
早期在管理Linux系统的网络时，常使用ifconfig及route之类的命令，不过如果你准备开始使用Linux强大的基于策略的路由机制，那么，就请不要使用这类工具了，因为这类工具根本无法用于功能强大的基于策略的路由机制，取而代之的工具是iproute。iproute这个软件在RedHat系列的Linux系统中是默认安装的，因此，你通常可以找到这个工具。如果真因为某些原因找不到这个软件，只要在使用Fedora或CentOS Linux时，在联网的情况下，用yum install iproute命令即可顺利安装；或者也可以使用ip -V命令来检查iproute软件是否已经安装，再次请注意，-V参数为大写的英语字母：
[root@localhost /]# ip -V ip utility, iproute2-ss091226 linux 高级路由即基于策略的路由比传统路由在功能上更强大，使用也更灵活，它不仅能够根据目的地址来转发路径而且也能够根据报文大小、应用或ip源地址来选择路由转发路径从而让系统管理员能轻松做到： 1、 管制某台计算机的带宽。 2、 管制通向某台计算机的带宽 3、 帮助你公平地共享带宽 4、 保护你的网络不受DOS的攻击 5、 保护你的Internet不受到你的客户的攻击 6、 把多台服务器虚拟成一台，并进行负载均衡或者提高可用性 7、 限制你的用户访问某些计算机 8、 限制对你的计算机的访问 9、 基于用户帐号、MAC地址、源IP地址、端口、QOS《TOS》、时间或者content等进行路由
一、管理策略数据库（ip rule） 在Linux下，基于策略路由的策略数据库是由ip命令来管理的，下面讨论“管理”的几个方面：
1、查看策略数据库 要查看策略数据库的内容，可以使用ip rule show命令，或者可以使用ip rule ls。如下是命令执行后所得到的输出结果，在这些数据中，可以看到系统的三条默认规则，而这三条规则默认分别对应于local、mail及default三个路由表。
[root@localhost /]# ip rule show 0: from all lookup local 32766: from all lookup main 32767: from all lookup default 2、添加规则 在添加规则时，必须先确定好“条件”、“优先级别”及“路由表ID”，此后才可以执行添加规则的操作。
2.1、条件 条件是用来决定哪类数据包可以符合这项规则，而可用来匹配的字段为Source IP、Destination IP、Type of Service、fwmark及dev等，这些字段的使用方式如下：</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/23-ip%E5%91%BD%E4%BB%A4%E4%B9%8Broute%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%90%AB%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/01-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/23-ip%E5%91%BD%E4%BB%A4%E4%B9%8Broute%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%90%AB%E4%B9%89/</guid><description>路由条目的意义 转载(https://www.cnblogs.com/yyleeshine/p/15185911.html)
路由的设计远比一般的理解要复杂的多。典型的路由条目包括了源IP，目的IP(缺省掩码为32)，网关IP，scope，dev和type六个要素。
路由表中包含3层路由表和2层路由表。一个要从本机发出去的包，无论目标地址是内网的其他服务器还是内网外的其他服务器，都要查看路由表，区别是发往同一个内网的包会匹配到2层路由表，而离开内网的包好会匹配到3层路由表。
via指定网关 网关IP就是在配置路由的时候指定的via后面的地址，在路由表中叫Gateway，这是说明这条路由的下一跳是这个IP地址。这个IP地址之所以出现，是因为目的地址不是当前自己出口可以直接可达的，需要经过网关路由到下个网络才能投递。
也就是因此，如果这个via域配置为0.0.0.0，或者是用*表示，总之是代表一定的通配，那么就意味着这个路由的目的地和自己在一个二层的网络，到达那个目的地并不需要网关转发，只需要配置MAC地址从端口上发出去即可。这个发送出去的过程显然是去查ARP表，通过IP地址查询目标的MAC地址。
很容易理解网关在路有条目中的意义，如果到达一个目标地址是需要通过网关转发出去的，via就要指定网关。大部分的个人局域网中，都会指定一个默认网关，目的IP填写了0.0.0.0，也就是所有的目的地址（通常使用命令的时候，这个词语叫做default），via后面填写网关地址。这样在其他的更精确的路由条目都不命中的情况下，就一定会命中这个默认路由条目。因为这个条目的目的IP设置是通配。使用ip命令设置这样的默认路由是ip route add default via 10.0.0.1。
dev指定设备 假设一个路由条目指定了gateway，那么决策还需要知道这个gateway到底是从哪个网口发出去可达的，这就是dev的作用。既然到一个gateway必然要从一个设备出去，而其他的地方并不能指定这个gateway和设备的对应关系，于是就在路由表这里就指定了。通过dev可以到达该gateway。
如果via gateway不指定，也就是该路由在同一个二层，那么仍然需要指定dev，因为即使是发送出去，也需要查从哪里发送出去。因为在收到一个数据包的时候，进入系统的时候目的IP不是自己就需要根据目的IP来查找路由，这个路由会决定这个目的IP是要转发给哪个端口（通常通过目的IP和网关IP和dev来决定）。
补充：不指定via GW，一般可以认为网关就是本机的网卡设备，有2种情况：
在veth-pair设备作为网关时使用。10.101.161.4 dev calia1f8336e816 scope link 二层路由：10.110.64.0/24 dev enp7s0f0.194 proto kernel scope link src 10.110.64.124 注意该条路由是因为配置网卡IP后由内核自动生成的，用于与该IP所在网段内的其他IP进行二层路由通信 scope Dev相对于对gateway的一个更小的约束。同样起到约束作用的还有scope。Scope是一个更小程度的约束，指明了该路由在什么场景下才有效(或者说流量在哪个范围下流转的时候该路由生效)。也是用于约束目的地址的。
例如不指定网关的二层路由，通常对应的scope类型是scope link（即不指定via GW，则默认的scope为link）。scope link的意义就是说明在同一个二层。这个意义与网关不指定的效果是呼应的。
有四种scope：global、link、host、site。
link是在链路上才有效(global是在任何的场景下都有效)，这个链路是指同一个端口，也就是说接收和发送都是走的同一个端口的时候，这条路由才会生效（也就是说在同一个二层）。
global则可以转发，例如从一个端口收到的包，可以查询global的路由条目，如果目的地址在另外一个网卡，那么该路由条目可以匹配转发的要求，进行路由转发。Link的scope路由条目是不会转发任何匹配的数据包到其他的硬件网口的。
host表示这是一条本地路由，典型的是回环端口，loopback设备使用这种路由条目，该路由条目比link类型的还要严格，约定了都是本机内部的转发，不可能转发到外部。
Site则是ipv6专用的路由scope。
总结:
global：默认值。网关单播路由。跨网络(不同的二层网络)，需要via指定下一跳。是三层转发。 link：直接单播、广播路由。同一个二层网络(同网段)下流量的流转。即目的地址是该网段的发包，都可以匹配这个路由。特点是所有的数据请求走二层arp实现路由，而不是走三层路由。是二层转发（scope link条目会匹配后，会通过arp去查看目标IP的MAC地址，该条目会在网卡配置ip的时候自动生成该ip所在网段的link条目，例如为eth0设备配置ip10.20.1.2/24时，会生成10.20.1.0/24 dev eth0 proto kernel scope link src 10.20.1.2） host：只在本地主机内部流转，比如回环网卡 site：ipv6专用的路由 src指定源IP 源IP是一个路由条目的重要组成部分，这个源IP的意义在于一个补充作用。匹配还是根据目的IP进行匹配，但是由于在查找路由条目的时候很可能源地址还没有指定。典型的就是没有进行bind的发送情况，通常是随机选择端口和按照一定的规则源地址。这个“一定的规则”就是在这里的路由条目的src域可以影响。也就是如果进程没有bind一个源地址，将会使用这里src域里面的源地址作为数据包的源地址进行发送。但是如果进程提前bind了，命中了这个条目，就仍然会使用进程bind的源地址作为数据包的源地址。所以说这里的src只是一个建议的作用。
# ip route default via 115.238.122.129 dev eth1 115.</description></item></channel></rss>