<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ljzsdut</title><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><description>Recent content on ljzsdut</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/1-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3%E5%8A%A8%E7%94%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/1-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3%E5%8A%A8%E7%94%BB/</guid><description>转载声明 动画：用动画给面试官解释 TCP 三次握手过程
动画：用动画给女朋友讲解 TCP 四次分手过程
一、TCP 是什么？ TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
我们知道了上述了解到了 TCP 的定义，通俗一点的讲，TCP 就是一个双方通信的一个规范标准（协议）。
我们在学习 TCP 握手过程之前，首先必须了解 TCP 报文头部的一些标志信息，因为在 TCP 握手的过程中，会使用到这些报文信息，如果没有掌握这些信息，在学习握手过程中，整个人处于懵逼状态，也是为了能够深入 TCP 三次握手的原理。
二、TCP 头部报文 2.1 source port 和 destination port 两者分别为「源端口号」和「目的端口号」。源端口号就是指本地端口，目的端口就是远程端口。
一个数据包（pocket）被解封装成数据段（segment）后就会涉及到连接上层协议的端口问题。
可以这么理解，我们可以想象发送方很多的窗户，接收方也有很多的窗户，这些窗口都标有不同的端口号，源端口号和目的端口号就分别代表从哪个规定的串口发送到对方接收的窗口。不同的应用程度都有着不同的端口，之前网络分层的文章中有提到过。 扩展：应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。
2.2 Sequence Numbe 称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。
再通俗一点的讲，每个字段在传送中用序列号来标记自己位置的，而这个字段就是用来完成双方传输中确保字段原始位置是按照传输顺序的。（发送方是数据是怎样一个顺序，到了接受方也要确保是这个顺序）
PS：初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x = ACK_y (x 的序列号 = y 发给 x 的 ACK)，这里后边会讲到。
2.3 Acknowledgment Numbe 称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2-OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8ETCPIP%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2-OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8ETCPIP%E6%A8%A1%E5%9E%8B/</guid><description>TCP/IP通信协议 应用层是由用户实现完成的，用户态；传输层、网络层、链路层是由内核完成的。
OSI七层模型 **应用层：**就是应用软件使用的协议，如邮箱使用的POP3，SMTP、远程登录使用的Telnet、获取IP地址的DHCP、域名解析的DNS、网页浏览的http协议等；这部分协议主要是规定应用软件如何去进行通信的。
**表示层：**决定数据的展现（编码）形式，如同一部电影可以采样、量化、编码为RMVB、AVI，一张图片能够是JPEG、BMP、PNG等。
**会话层：**为两端通信实体建立连接（会话），中间有认证鉴权以及检查点记录（供会话意外中断的时候可以继续，类似断点续传）。
**传输层：**将一个数据/文件斩件分成很多小段，标记顺序以被对端接收后可以按顺序重组数据，另外标记该应用程序使用的端口号及提供QOS。（不同的应用程序使用不同计算机的端口号，同样的应用程序需要使用一样的端口号才能正常通信）
**网络层：**路由选路，选择本次通信使用的协议（http、ftp等），指定路由策略及访问控制策略。（IP地址在这一层）
**数据链路层：**根据端口与MAC地址，做分组（VLAN）隔离、端口安全、访问控制。（MAC地址在这一层）处理VLAN内的数据帧转发，跨VLAN间的访问，需要上升到网络层。
**物理层：**将数据最终编码为用0、1标识的比特流，然后传输。（例如将题主头像的图片，变为一串01100111100这样的数字来表示）。
手动感受一下什么是连接？ # 建立连接 #使用exec命令创建一个文件描述符(8), 本质上是一个连接(或者说是socket)，该连接映射到了www.baidu.com #连接时双向的，使用&amp;#34;&amp;lt;&amp;gt;&amp;#34;表示输入输出 [root@VM ~]# exec 8&amp;lt;&amp;gt; /dev/tcp/www.baidu.com/80 # 传送数据：发送一个Get请求到fd [root@VM ~]# echo -e &amp;#39;GET / HTTP/1.0\n&amp;#39; &amp;gt;&amp;amp; 8 # 传送数据：从fd中获取相应报文 [root@VM ~]# cat &amp;lt;&amp;amp; 8 HTTP/1.0 200 OK Accept-Ranges: bytes Cache-Control: no-cache Content-Length: 14615 Content-Type: text/html Date: Thu, 22 Apr 2021 02:56:07 GMT ...... # 查看创建的fd(文件描述符) （在当前的bash session下查看） [root@VM ~]# ll /proc/$$/fd 总用量 0 lrwx------ 1 root root 64 4月 22 10:54 0 -&amp;gt; /dev/pts/13 lrwx------ 1 root root 64 4月 22 10:54 1 -&amp;gt; /dev/pts/13 lrwx------ 1 root root 64 4月 22 10:54 2 -&amp;gt; /dev/pts/13 lrwx------ 1 root root 64 4月 22 10:58 255 -&amp;gt; /dev/pts/13 lrwx------ 1 root root 64 4月 22 10:58 8 -&amp;gt; socket:[2325470] 第2种方式：</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3-%E8%AE%B0%E4%B8%80%E6%AC%A1TCPIP%E5%AE%8C%E6%95%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3-%E8%AE%B0%E4%B8%80%E6%AC%A1TCPIP%E5%AE%8C%E6%95%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/</guid><description>转载
文章1：记一次TCP/IP完整的数据包传输过程 知识点 读此文章之前，先弄懂下面5个基本知识点：
封装报文是从上层到下层(应用层 &amp;ndash;&amp;gt; 传输层 &amp;ndash;&amp;gt; 网络层 – &amp;gt; 数据链路层 &amp;ndash;&amp;gt; 物理层)，解封装报文是从下层到上层。 实际例子：从PC1远程登录服务器(Server)。 数据包传输的过程中，源IP和目标IP不会变，除非遇到NAT（SNAT或DNAT)，源MAC和目标MAC遇到网关会变。 二层内通过MAC寻址，三层通过IP寻址。 当一个数据包的目的地址不是本机，所以需要查询路由表，当查到路由表中的网关之后，需要获取网关的MAC地址，并将数据包的MAC地址修改成网关地址，然后发送到对应的网卡。 协议数据单元在应用层、表示层和会话层被称做数据(Data)，在传输层被称做分段(Segment)，在网络层被称做包(Packet)，在数据链路层被称做帧(Frame)，在物理层被称做比特(Bit)。 PC1或者Server上保留的arp表是：arp和ip的映射关系。而二层交换机是arp和端口的映射关系，也就是这个arp 应该由哪个端口转发。三层交换机可以保留arp和ip的映射关系。 PC1发送http请求到Server的详细流程 这张图片会贯穿本文始终
步骤1、数据包会在PC1中先封装好 这个你要首先弄明白，当数据包从PC1发出时，它已经是一个完整的包了，包含如下信息：
PC1发出的包所包含的信息
应用层：HTTP协议是生成针对目标WEB服务器的HTTP请求报文，该报文就是需要传递的数据
传输层：HTTP协议使用的是TCP协议，为了方便通信，将HTTP请求报文按序号分为多个报文段(segment)，并对每个报文段进行封装。PC1使用本地一个大于1024以上的随机TCP源端口(这里假设是1030)建立到目的服务器TCP80号端口的连接，TCP源端口和目的端口加入到报文段中，学名叫协议数据单元(Protocol Data Unit, PDU)。因TCP是一个可靠的传输控制协议，传输层还会加入序列号、窗口大小等参数
网络层：下沉到网络层后，封装网络层的头部，主要就是添加源和目的IP地址，成为数据包。用户通常使用主机名或域名来访问服务器，这时就需要通过应用层的DNS服务来通过域名查找IP地址，或逆向从IP地址反查域名。这里的源IP地址是193.1.1.2，目的IP地址是195.1.1.2。
数据链路层：下沉到数据链路层，封帧的头部，源MAC和目标MAC。PC1比较去往的目标IP，发现Server IP 195.1.1.2不在本地网络中，PC1通过查找本地路由表，会有一条默认路由指向网关R1，知道数据包要先发到网关R1的Fa0/0口。PC1查找本地arp cache，如果找到193.1.1.1对应的MAC地址则进行封装; 如果在ARP cache中没有找到193.1.1.1对应的MAC地址，则用ARP协议，査询到网关对应的MAC地址 “00-11-BC-7D-25-03” 。于是，这里的源MAC地址是PC1的MAC地址“00-1B-24-7D-25-01”，目的MAC地址是网关的MAC地址“00-11-BC-7D-25-03。
从PC1发出的数据帧格式：
物理层：数据链路层封装后的数据帧下沉到物理层，转换成二进制形式的比特(Bit)流，从PC1的网卡发送出去。
步骤2、数据包到达集线器 对你没看错，这里PC1外接的是一个集线器，按理说这么古老的设备是不应该出现在这里的，但是为了能够全方位的描述一些你常见到的设备，这里有意为之，安排了一个集线器。
PC1发出的比特流到达集线器，集线器简单地对比特流转发，从除接收端口以外的所有端口转发出去。PC2接收到这个数据包，把比特流转换成帧上传到数据链路层，PC2比较数据帧的目的MAC地址，发现与本机网卡的MAC地址不同，PC2丢弃该数据帧，放弃处理，数据到达路由器。
步骤3、数据包到达路由器R1 路由器R1收到该比特流，转换成帧上传到数据链路层，路由器R1比较数据帧的目的MAC地址，发现与路由器接收端口Fa0/0(快速以太网，简写成Fa0/0，指的是0号插槽上编号为0的接口)的MAC地址相同，路由器知道该数据帧是发往本路由器的。路由器R1的数据链路层把数据帧进行解封装，然后上传到路由器R1的网络层，路由器R1看到数据包的目的IP地址是195.1.1.2，并不是发给本路由器的，需要路由器进行转发。
路由器R1査询自己的路由表，发现数据包应该从串行接口S1/1发出。路由器R1把数据包从Fa0/0接口交换(forward)到S1/1接口。
此时R1并不能直接把这个数据包发出去，因为在R1的Fa0/0接口被解封装，现在需要被重新再封装，即在路由器的入接口解封装，在路由器的出接口需要再封装。网络层的封装并没有被解开，但并不意味着网络层的信息一点都没有改变，其实网络层的数据包中源和目的IP地址都没有被改变(除非在网络地址转换的情况下)，但TTL(生存周期)会减1。
网络层把数据包交给下层的数据链路层，数据链路层需要封装二层的地址。路由器间一般使用串行链路互联。串行链路不同于以太网，因为以太网是一个多路访问的网络，要定位到目的设备需要借助于MAC地址，但串行线路一般的封装协议都是PPP(Point-to-Point Protocol,点到点协议)或HDLC(High-Level Data Link Control,高级数据链路控制协议)封装，这种封装被用于点对点线路，也就是说，一根线缆只连接两台设备，一端发出，另一端肯定可以收到（有点像容器网络中用的veth）。假设串行线缆上使用的是PPP协议，则数据链路层封装的源和目的地址都是PPP。
数据链路层封装后的数据帧被传到物理层，转换成二进制形式的比特流，从路由器R1的S1/1接口发送出去
从R1的S1/1发送出去的包的数据帧格式：
步骤3、数据包到达R2 路由器R2收到这个比特流，上传至数据链路层，数据链路层去掉PPP的封装。路由器R2査询数据包的目的IP地址，发现该IP网络直接连接在Fa0/0接口，路由器R2把数据包交换到Fa0/0接口。路由器查看本地的ARP缓存，如果找到195.1.1.2对应的MAC地址，则直接进行封裝；如果没有找到，则发送ARP的查询包。路由器R2发出数据帧的源地址是Fa0/0接口的MAC地址，目的地址是服务器网卡的MAC地址。
数据链路层封装后的数据帧被传到物理层，转换成二进制形式的比特流，从路由器R2的Fa0/0接口发送出去。
源MAC已经变为R2的F0/0的MAC，目标MAC则根据ARP求得
步骤5、交换机处理 路由器R2发出的比特流到达交换机，根据源MAC地址进行学习，根据目的MAC地址进行转发。交换机根据数据帧中的目的MAC地址査询MAC地址表，把比特流从对应的端口发送出去，交换机把比特流发往服务器，并没有发往PC3。可以看到交换机并没有像集线器那样进行广播转发，而是有针对性的进行了转发。
步骤6、服务器处理 服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层，服务器发现数据帧中的目的MAC地址与本网卡的MAC地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层。服务器的网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层。传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性。数据最后被传到服务器的应用层。
反向传输 服务器收到PC1发过来的数据后，对PC1进行响应。和PC1处理的过程类似，服务器也知道要发往一个远程的网络，数据链路层的目的MAC地址需要封装网关的MAC地址；网络层源和目的IP地址与PC1发送过来的包相反，即把源地址变成目的地址，目的地址变成源地址；传输层源和目的端口与PC1发送过来的包相反，即把源端口变成目的端口，目的端口变成源端口。
总结 从PC1到Server的整个数据包流动过程，PC1执行OSI七层的封装，然后把比特流传到集线器；集线器在物理层把信号简单放大后（这是它的主要功能，为了增加有效的传输距离），把比特流传到路由器R1；R1执行OSI下三层的处理后，再把比特流传到路由器R2；R2执行OSI下三层的处理后，再把比特流传到交换机；交换机执行OSI下二层的处理后，再把比特流传到服务器
从这个流动过程中，可以发现数据流在中间设备上主要执行的是OSI下三层的操作。
物理层的设备不改变帧的格式，广播式转发。 数据链路层的设备也不改变帧的格式（比如二层交换机），但可以根据数据帧中的目的MAC地址进行转发； 网络层的设备改变帧的格式，要执行帧的解封装和再封装，但不改变数据包中的源和目的IP地址（NAT除外），即每一跳只会变更目标MAC地址。 文章2：IP报文经过路由器的转发过程及变化 动画演示分层封包、解包 跨路由的封包、解包过程 路由器收到数据包后，报文送到数据链路层，数据链路层解封以太网帧头部，提取目的MAC地址 查看目的MAC地址是不是自己本身的MAC地址。这个时候出现两种情况，具体如下： 情况1：是本机的MAC地址，则把报文传到网络层，由网络层继续解析。 情况2：不是本机的MAC地址，则丢弃报文。 假设是情况1，目的MAC是自己的MAC，把报文送到网络层解析。 **送到网络层后，网络层解析，提取目的IP地址，判断目的IP地址是不是本机的IP地址。**这个时候再次出现两种情况，具体如下： 情况1：是本机IP，则把报文送到上层，由传输层进行解析。由于本次主要讲解转发流程，就不讲传输层解析的过程了。 情况2：不是本机IP，则去查路由表，匹配出接口。 假设是情况2，不是本机IP，查路由表根据路由的最长掩码匹配原则，匹配路由表，找到出接口。查路由的时候会出现四种情况，具体如下： 情况1：没有匹配路由，无法继续转发，则丢弃报文。并向源IP发送目的不可达的ICMP报文。 情况2：匹配直连路由，网络层封装目的IP和源IP，使用目的IP地址查ARP表。寻找目的MAC。 情况3：匹配非直连路由，网络层封装目的IP和源IP，使用路由表里的下一跳IP地址查ARP表（不会修改目的IP）。寻找下一跳IP地址的目的MAC。 情况4：匹配默认路由，网络层封装目的IP和源IP（不会修改IP），使用路由表里的下一跳IP地址查ARP表。寻找下一跳IP地址的目的MAC。 假设匹配到路由，去ARP表，匹配目的IP对应的MAC地址。这个时候出现两种情况，具体如下： 情况1：在ARP表里匹配到了对应的MAC地址，则把匹配到的MAC封装到帧头部的目的MAC，把本机出接口的MAC封装到帧头部的源MAC里。然后发送出去。 情况2：在ARP表里没有匹配到对应的MAC地址，则发送ARP请求，寻找目的IP对应的MAC地址。 假设没有匹配到对应的MAC地址，发送ARP请求，这个时候会遇到两种情况。具体如下： 情况1：没有收到ARP响应，无法继续获取目的IP对应的MAC地址。则丢弃报文。 情况2：收到了ARP响应，首先把响应报文中的源MAC解析出来，然后把目的IP和从响应报文中获取的源MAC放到ARP表中，形成映射关系，并对这个映射关系添加老化时间。然后把MAC封装到目的MAC里，把本机出接口的MAC封装到源MAC里，然后发送出去。 说明：</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TIME_WAIT%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5%E8%BF%87%E5%A4%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TIME_WAIT%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5%E8%BF%87%E5%A4%9A/</guid><description>TCP连接断开的四次挥手 四次挥手过程 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。其原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段1）。
（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段2）。和SYN一样，一个FIN将占用一个序号。
（3） 服务器关闭客户端的连接，发送一个FIN给客户端（报文段3）。
（4） 客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段4）。
双方状态详解 ESTABLISHED： 双方建立了连接。
FIN_WAIT_1： 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。
FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。
TIME_WAIT： 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。
CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。
LAST_ACK： 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。
我们可以看到，主动关闭方在接收到对方发送的FIN报文后会进入TIME_WAIT状态等待2MSL时长。
RFC 793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，以Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒，
为什么需要TIME_WAIT？ 为实现TCP全双工连接的可靠释放 为使旧的数据包在网络因过期而消失 1.为实现TCP全双工连接的可靠释放
**TIME_WAIT是为了等待足够的时间以确保主动关闭方最后发送的ACK能够让被动关闭方接受，从而使其正确关闭。**由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。
2.为使旧的数据包在网络因过期而消失
TIME_WAIT状态会持续2MSL时长，这个时长足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失。再出现的数据包一定就是新连接产生的。
MSL（Maximum Segment Lifetime）最大报文生存时间：每个TCP实现必须选择一个MSL。它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL时间。RFC 793指出MSL为2分钟，现实中常用30秒或1分钟。
为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。而TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由其中一方发送的数据到达另外一方后，会被这一方的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。
TIME_WAIT过多的危害 TIME_WAIT状态是TCP链接中正常产生的一个状态，但凡事都有利弊，TIME_WAIT状态过多会存在以下的问题：
内存资源占用：大量的time_wait状态也会系统一定的fd，内存和cpu资源，当然这个量一般比较小，并不是主要危害
对端口资源的占用，一个 TCP 连接至少消耗&amp;quot;发起连接方&amp;quot;的一个本地端口；
第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过如下参数设置指定：
net.ipv4.ip_local_port_range = 32768 61000 如果“发起连接方”的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。
客户端（发起连接方）受端口资源限制： ​ 客户端TIME_WAIT过多，在socket的TIME_WAIT状态结束之前，该socket所占用的本地端口号将一直无法释放。在高并发（每秒几万qps）并且采用短连接方式进行交互的系统中运行一段时间后，系统中就会存在大量的time_wait状态，如果time_wait状态把系统所有可用端口都占完了且尚未被系统回收时，就会出现无法向服务端创建新的socket连接的情况。此时系统几乎停转，任何链接都不能建立。端口就 65536 个，被占满就会导致无法创建新的连接。
服务端（被动连接方）受系统资源限制： ​ 由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，因为服务端只监听一个端口，不会因为 TCP连接过多而导致端口资源受限。但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等，当然这个量一般比较小，并不是主要危害。</description></item><item><title/><link>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0ip_forward%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://note.ljzsdut.com/%E7%BD%91%E7%BB%9C/04-TCP-IP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0ip_forward%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/</guid><description>概述 在服务器上，我们一般会根据官方文档或者遇到网络不通的时候，去设置ip_forward设置为1，问题虽然解决了，可能并不清楚ip_forward背后的原理，本篇文章将一探究竟。
为什么要设置ip_forward为1？ ip_forward在协议栈处理的哪个过程中生效？ 如何在繁杂的内核代码中找到处理ip_forward相关的流程。 ip_forward作用 一般来说，一台服务器只处理mac地址和ip地址为本机的数据包，即ip_forward默认为0。但是随着云和虚拟网络的发展，linux可以作为一个软路由转发路过的数据包。因此当需要宿主机处理目的地址非本机的数据包时，需要使能ip_forward。
// 临时生效，永久生效，需要修改/etc/sysctl.conf文件 echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward ip_forward在哪个处理过程中生效 还是用经典的netfilter的框架图。
这里只分析最简单的一种情况，单播。下面这段代码是路由查找过程中的一个函数，从上面的图看出，在prerouting后，要经过router模块，去判断该包的类型，是送往本机的包，还是需要转发的包。注意这里的转发可以是直接出物理网卡，也可以是转发到主机的其他虚拟网卡这张图是三层的处理，能到prerouting进行处理，说明mac地址是已经匹配了的。
static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr, u8 tos, struct net_device *dev, struct fib_result *res) { struct in_device *in_dev = __in_dev_get_rcu(dev); // 查找路由表 err = fib_lookup(net, &amp;amp;fl4, res, 0); // 本机的包，继续处理 if (res-&amp;gt;type == RTN_LOCAL) { err = fib_validate_source(skb, saddr, daddr, tos, 0, dev, in_dev, &amp;amp;itag); if (err &amp;lt; 0) goto martian_source; goto local_input; } // 非本机的包，如果ip_forward未使能，返回错误 if (!</description></item></channel></rss>